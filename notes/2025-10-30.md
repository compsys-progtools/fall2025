---
file_format: mystnb
kernelspec:
    name: python3
---

# What happens when I build code in C?



+++{"lesson_part": "main","type","heading"}
## What is *buiding* code?

Building is transforming code from the input format to the final format.  

This can mean different things in different contexts. For example:
- the course website is built from markdown files in to html output using myst
- the courseutils docs are built from the python docstrings and markdown with sphinx
- a C program is built  C source code to executable as the output

+++{"lesson_part": "main"}
We sometimes say that compiling takes code from source to executable, but this process is actually multiple stages and compiling is *one* of those steps.

+++{"lesson_part": "main"}

We will focus on *what* has to happen more than *how* it all happens.  

+++{"lesson_part": "main"}
CSC301, 402, 501, 502 go into greater detail on how languages work.  

Our, here, goal is to:

- (where applicable) give you a preview
- get enough understanding of what happens to know where to look when debugging



+++{"lesson_part": "main","type":"heading"}


## Using SSH Keys

We are going to work on seawulf so that we all have the same compiler. 


```{code-cell} bash
:tags: ["skip-execution"]
ssh seawulf
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Last login: Tue Oct 28 12:58:26 2025 from 172.20.24.214
```



+++{"lesson_part": "main"}
## Using an interactive session

Last class we worked on the login node, but that is not best practice. 

Today we will use an interactive session using the `salloc` program. 


```{code-cell} bash
:tags: ["skip-execution"]
salloc
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
salloc: Granted job allocation 28290
salloc: Waiting for resource configuration
salloc: Nodes n005 are ready for job
```

+++{"lesson_part": "main"}
We will make an empty directory to work in for today. 
```{code-cell} bash
:tags: ["skip-execution"]
mkdir compilec
cd compilec/
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

an empty folder!

+++{"lesson_part": "main"}
## Overall Build process

````{figure}
```{mermaid}
flowchart TD
    a[[system files]] --> |lib.o| linker
    write{write code} --> |my_program.c| preprocessor 
    preprocessor --> |my_program.i | compiler
    compiler --> |my_program.s| assembler 
    assembler --> |my_program.o| linker 
    linker --> |my_program, my_program.exe| run{run code}
    b[[build dir]] --> |helper.o| linker
```
````

+++{"lesson_part": "main","type":"heading"}


### A simple program


We will use `nano` to write a very small program:

```{code-cell} bash
:tags: ["skip-execution"]
nano hello.c
```

+++{"lesson_part": "main","type":"output"}

```{code-block} C
:filename: hello.c
#include <stdio.h>
void main () {

 printf("Hello world\n");

}
```

+++{"lesson_part": "main"}
and again, see what is in our file
```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
hello.c
```

+++{"lesson_part": "main"}
+++{"lesson_part": "main"}

### Preprocessing with gcc

First we handle the preprocessing which pulls in headers that are included.  We will use the compiler
[gcc](https://man7.org/linux/man-pages/man1/gcc.1.html)


+++{"lesson_part": "main"}

We will use `gcc` for many steps, and use its options to have it do subsets of what it can possibly do: 

- `-E` stops after preprocessing
- `-o` makes it write the .i file and passes the file name for it

```{code-cell} bash
:tags: ["skip-execution"]
gcc -E hello.c -o hello.i
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

+++{"lesson_part": "main"}
If it succeeds, we see no output, but we can check the folder
```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
hello.c  hello.i
```
now we have a new file
+++{"lesson_part": "main"}

We can inspect what it does using `wc`
```{code-cell} bash
:tags: ["skip-execution"]
wc -l hello.*
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
    6 hello.c
  842 hello.i
  848 total
```
we started with just 6 lines of code and the preprocessing added a lot of lines
+++{"lesson_part": "main"}
Since it is long, we will fist look at the top
```{code-cell} bash
:tags: ["skip-execution"]
head hello.i
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
# 1 "hello.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "hello.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 375 "/usr/include/features.h" 3 4
```


+++{"lesson_part": "main"}
and the end
```{code-cell} bash
:tags: ["skip-execution"]
tail hello.i
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console

extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 943 "/usr/include/stdio.h" 3 4

# 2 "hello.c" 2
void main () {

 printf("Hello world\n");

}
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
cat hello.c
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
#include <stdio.h>
void main () {

 printf("Hello world\n");

}
```

we see that our original program, is at the end of the file, and the beginning is where the include line has been expanded. 

+++{"lesson_part": "site"}

````{margin}
```{admonition} Try it yourself
Look at this whole file, try changing the base program to remove the include and then see what the preprocessed file is like
```

```{note}
I have set this cell to use C syntax highlighting even though on a terminal output it would not
```
````
+++{"lesson_part": "main","type":"heading"}

### Compiling

Next we take our preprocessed file and compile it to get assembly code.



+++{"lesson_part": "main"}

Again, we use `gcc`:
- `-S` tells it to produce assembly
- we will use the preprocessed file as input

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
gcc -S hello.i
```

+++{"lesson_part": "main"}
but we can see what it output: 
```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
hello.c  hello.i  hello.s
```


we have a new file as well with the `.s` extension. 

+++{"lesson_part": "main"}
Again, lets inspect

```{code-cell} bash
:tags: ["skip-execution"]
wc -l hello.*
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
    6 hello.c
  842 hello.i
   25 hello.s
  873 total
```


this is longer than the source, but not as long as the header. The header contains lots of information that we *might* need, but the assembly is only what we *do*. 

+++{"lesson_part": "main"}

And it's manageable, so we inspect it directly:

```{code-cell} bash
:tags: ["skip-execution"]
cat hello.s
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
	.file	"hello.c"
	.section	.rodata
.LC0:
	.string	"Hello world"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$.LC0, %edi
	call	puts
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)"
	.section	.note.GNU-stack,"",@progbits
```



There are many more steps and they are lower level operations, but it is still human readable text stored in the file.



+++{"lesson_part": "site"}
```{hint}
Learning more about assembly languages is a good explore badge topic
```


+++{"lesson_part": "main","type":"heading"}


### Assembling


Assembling is to take the assembly code and get object code.  Assembly is relatively broad and there are families of assembly code, it is also still written *for humans* to understand it readily.  It's more complex than source code because it is closer to the hardware.  The object code however, is specific instructions to your machine and not human readable.



+++{"lesson_part": "main"}

Again, with `gcc`:
- `-c` tells it to stop at the object file
- `-o` again gives it the name of the file to write


```{code-cell} bash
:tags: ["skip-execution"]
gcc -c hello.s -o hello.o
```



+++{"lesson_part": "main"}
Again, check what it does by looking at files
```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
hello.c  hello.i  hello.o  hello.s
```
now we see a new file, the `.o`



+++{"lesson_part": "main"}
and again check its length
```{code-cell} bash
:tags: ["skip-execution"]
wc -l hello.*
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
    6 hello.c
  842 hello.i
    5 hello.o
   25 hello.s
  878 total
```
this is very short
+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
wc  hello.o
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
   5   17 1496 hello.o
```
it is not even too many characters
+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
cat hello.o
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
ELF>?@@
UH???]?Hello worldGCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)zRx
K                                                               A?C
??      hello.cmainputs


???????? .symtab.strtab.shstrtab.rela.text.data.bss.rodata.comment.note.GNU-stack.rela.eh_frame @?0
&PP1P
     90\.B?W?R@
?
	?0a
```

This is not human readable, though





+++{"lesson_part": "main"}

### Linking

Now we can link it all together; in this program there are not a lot of other depdencies, but this fills in anything from libraries and outputs an executble



+++{"lesson_part": "main"}

once again with `gcc`:
-  `-o` flag specifies the name for output
-  `-lm` tells it to link from the .o file.

```{code-cell} bash
:tags: ["skip-execution"]
gcc -o hello hello.o -lm
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
hello  hello.c  hello.i  hello.o  hello.s
```


+++{"lesson_part": "main"}
 If we look at the permissions
```{code-cell} bash
:tags: ["skip-execution"]
ls -l
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
total 44
-rwxr-xr-x. 1 brownsarahm spring2022-csc392  8360 Oct 30 12:59 hello
-rw-r--r--. 1 brownsarahm spring2022-csc392    64 Oct 30 12:40 hello.c
-rw-r--r--. 1 brownsarahm spring2022-csc392 16865 Oct 30 12:45 hello.i
-rw-r--r--. 1 brownsarahm spring2022-csc392  1496 Oct 30 12:55 hello.o
-rw-r--r--. 1 brownsarahm spring2022-csc392   433 Oct 30 12:49 hello.s
```

we can see that the executable file was automatically given `x` permissions for everyone.  

+++{"lesson_part": "main"}
the executable is not readable though
```{code-cell} bash
:tags: ["skip-execution"]
cat hello
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
ELF>P@@(@8	@@@@@@?88@8@@@ ``48 ``?TT@T@DDP?td??@?@44Q?tdR?td``/lib64/ld-linux-x86-64.so.2GNU GNU?hm|Y??!w\??د5P?S$)
                                        libm.so.6__gmon_start__libc.so.6puts__libc_start_mainGLIBC_2.2.5ui	;?`` `(`H?H?
                                             H??t?CH???5?
                                                          ?%?
                                                              @?%?
                                                                   h??????%?
                                                                             h??????%?
      h?????1?I??^H??H???PTI???@H??P@H??=@?????fD??`UH-8`H??H??w]øH??t?]?8`????8`UH-8`H??H??H??H???H?H??u]úH??t?]H?ƿ8`????==
                                            uUH???~???]?*
                                                          ??@H?= t?H??tU?`H????]?{????s???UH???@?????]?AWA??AVI??AUI??ATL?% UH?- SL)?1?H??H??e???H??t?L??L??D??A??H??H9?u?H?[]A\A]A^A_Ðf.???H?H??Hello world0$???|d???LQ????d????????
                                                                   zRx
                                                                     ???*zRx
                                                                           $????@FJ
K ??;*3$"D????A?C
Dd????eB?E?E ?E(?H0?H8?M@l8A0A(B BB?????@?@
???o?@@?@                                  ?@
G
 `H?@?@ ???oh@???o???o`@`&@6@F@GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)8@T@t@?@?@@`h@	?@
@8#T@T 1t@t$D???o?@N
  ?@                ?@?V@G^???o`@k???oh@hz?@?B?@???@??@@?P@Pr??@?	??@??@?4?`???0`04`4?04-h?.`4`??  P
  
```

+++{"lesson_part": "main"}

Now we can run the program
```{code-cell} bash
:tags: ["skip-execution"]
./hello 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Hello world
```

succes!! 



+++{"lesson_part": "main"}
## Putting it all together


We can repeat with a different name for the executable and work directly from source to executable: 

```{code-cell} bash
:tags: ["skip-execution"]
gcc -o demohello hello.c -lm
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

+++{"lesson_part": "main"}
check what it looks like
```{code-cell} bash
:tags: ["skip-execution"]
ls -l
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
total 56
-rwxr-xr-x. 1 brownsarahm spring2022-csc392  8360 Oct 30 13:03 demohello
-rwxr-xr-x. 1 brownsarahm spring2022-csc392  8360 Oct 30 12:59 hello
-rw-r--r--. 1 brownsarahm spring2022-csc392    64 Oct 30 12:40 hello.c
-rw-r--r--. 1 brownsarahm spring2022-csc392 16865 Oct 30 12:45 hello.i
-rw-r--r--. 1 brownsarahm spring2022-csc392  1496 Oct 30 12:55 hello.o
-rw-r--r--. 1 brownsarahm spring2022-csc392   433 Oct 30 12:49 hello.s
```

only an executable no intermediate files.  It still did all of those *proesses* but it didn't write files for them. 
+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
./demohello 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Hello world
```

+++{"lesson_part": "main"}
If we edit the source: 
```{code-cell} bash
:tags: ["skip-execution"]
nano hello.c
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
:filename: hello.c
#include <stdio.h>
void main () {

 printf("Hello world!\n");

}
```

+++{"lesson_part": "main"}
the executable does not change
```{code-cell} bash
:tags: ["skip-execution"]
./hello 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Hello world
```

+++{"lesson_part": "main"}
until we build it again, which we can do from source

```{code-cell} bash
:tags: ["skip-execution"]
gcc -o demohello hello.c -lm
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

+++{"lesson_part": "main"}
and then run
```{code-cell} bash
:tags: ["skip-execution"]
./demohello 
```

+++{"lesson_part": "main","type":"output"}
Now it's changed.
```{code-block} console
Hello world!
```



+++{"lesson_part": "main","type":"heading"}

## Working with multiple files

This all looks a bit different if we have our code split across files.
+++{"lesson_part": "main"}

we will make a new file `main.c`
```{code-cell} bash
:tags: ["skip-execution"]
nano main.c
```


+++{"lesson_part": "main","type":"output"}

```{code-block} C
:filename: main.c
/* Used to illustrate separate compilation.
Created: Joe Zachary, October 22, 1992
Modified:
*/

#include <stdio.h>

void main () {
 int n;
 printf("Please enter a small positive integer: ");
 scanf("%d", &n);
 printf("The sum of the first n integers is %d\n", sum(n));
 printf("The product of the first n integers is %d\n", product(n));
}
```

+++{"lesson_part": "main"}
Then `help.c` 

```{code-cell} bash
:tags: ["skip-execution"]
nano help.c
```

+++{"lesson_part": "main","type":"output"}

```{code-block} C
:filename: help.c
/* Used to illustrate separate compilation

Created: Joe Zachary, October 22, 1992
Modified:

*/

/* Requires that "n" be positive. Returns the sum of the
  first "n" integers. */

int sum (int n) {
 int i;
 int total = 0;
 for (i = 1; i <= n; i++)
  total += i;
 return(total);
}


/* Requires that "n" be positive. Returns the product of the
  first "n" integers. */

int product (int n) {
 int i;
 int total = 1;
 for (i = 1; i <= n; i++)
  total *= i;
 return(total);
}
```


+++{"lesson_part": "main"}

First we will compile and assemble the `main.c`
```{code-cell} bash
:tags: ["skip-execution"]
gcc -Wall -g -c main.c
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
main.c:8:6: warning: return type of ‘main’ is not ‘int’ [-Wmain]
 void main () {
      ^
main.c: In function ‘main’:
main.c:12:2: warning: implicit declaration of function ‘sum’ [-Wimplicit-function-declaration]
  printf("The sum of the first n integers is %d\n", sum(n));
  ^
main.c:13:2: warning: implicit declaration of function ‘product’ [-Wimplicit-function-declaration]
  printf("The product of the first n integers is %d\n", product(n));
  ^
```

we get some warnings, but that is okay

+++{"lesson_part": "main"}

next we do the same for the helpers
```{code-cell} bash
:tags: ["skip-execution"]
gcc -Wall -g -c help.c
```



+++{"lesson_part": "main"}
finally we link them togehter
```{code-cell} bash
:tags: ["skip-execution"]
gcc -o demo -lm main.o help.o
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

+++{"lesson_part": "main"}
now it runs: 
```{code-cell} bash
:tags: ["skip-execution"]
./demo
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Please enter a small positive integer: 5
The sum of the first n integers is 15
The product of the first n integers is 120
```

+++{"lesson_part": "main"}
we can modify one part
```{code-cell} bash
:tags: ["skip-execution"]
nano main.c
```

+++{"lesson_part": "main","type":"output"}

```{code-block} C
:filename: main.c
/* Used to illustrate separate compilation.
Created: Joe Zachary, October 22, 1992
Modified:
*/

#include <stdio.h>

void main () {
 int n;
 printf("Enter a small positive integer: ");
 scanf("%d", &n);
 printf("The sum of the first n integers is %d\n", sum(n));
 printf("The product of the first n integers is %d\n", product(n));
}
```

+++{"lesson_part": "main"}

We need to recompile and reassemble that part. 
```{code-cell} bash
:tags: ["skip-execution"]
gcc -Wall -g -c main.c
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
main.c:8:6: warning: return type of ‘main’ is not ‘int’ [-Wmain]
 void main () {
      ^
main.c: In function ‘main’:
main.c:12:2: warning: implicit declaration of function ‘sum’ [-Wimplicit-function-declaration]
  printf("The sum of the first n integers is %d\n", sum(n));
  ^
main.c:13:2: warning: implicit declaration of function ‘product’ [-Wimplicit-function-declaration]
  printf("The product of the first n integers is %d\n", product(n));
  ^
```

+++{"lesson_part": "main"}
and re-link, but we do not have to recompile or reassemble the help.c file; the orignal object file works well. 
```{code-cell} bash
:tags: ["skip-execution"]
gcc -o demo -lm main.o help.o
```


+++{"lesson_part": "main"}
and we can run the code
```{code-cell} bash
:tags: ["skip-execution"]
./demo
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Enter a small positive integer: 7
The sum of the first n integers is 28
The product of the first n integers is 5040
```

## Why this is important

The build process includes different steps, so an error at different steps tell you to look in differen places for the source of the problem. 

Consider the following:
- Where should you look if it says a linking error? 
- If it's a compiler error, where should you look?
- What step would catch syntax errors? 

Having a modular process means that for large, complex code bases, the parts can be split up.  It also means that if you only change one part of the code you only need to recompile that part.  For complex code the compilation and the optimizations that happen at compile time can take time.  That means you dont' have to that all the time. 

Efficient code development means not only less waiting for you, but a smaller environmental impact while you work and when your code is distributed. 


## Prepare for Next Class 

```{include} ../_prepare/2025-11-04.md
```

## Badges

`````{tab-set}
````{tab-item} Review
```{include} ../_review/2025-10-30.md
```

````

````{tab-item} Practice
```{include} ../_practice/2025-10-30.md
```

````
`````



## Experience Report Evidence

## Questions After Today's Class 

### Is it possible to reverse engineer source code from compiled code?

From the assembly, the output of the compiler it is definitely possible, but, it is lossy.  Many different source codes can produce equivalent assembly code. 

::::{tip}
Doing an experiment around this is a good explore badge topic
::::

From the executable it is a lot harder, but not compeltely impossible to get something close. 

### What happens when you give gcc a "preprocessed" file that isn't actually preprocessed during the compilation stage?

 This is an explore badge, try this out and see how it works. 

### What’s actually inside the object file before linking?

The <wiki:Object_code> is executable, but mising some dependencies from modular code or precompiled libraries.  We will learn more about these instruction sets next! 

### What higher level courses focus on assembly code?

There are not full courses on assembly exclusively here but CSC411 in some sections does (Alvarez/Estevs version does; Daniels version focuses on optimization using Rust instead of authoring in assembly). 

301 is the prereq but then 402 has more about how progrmaming languages are developed and how to execute code with interpreters and compilers.  