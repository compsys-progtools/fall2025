---
kernelspec:
    name: python3
---


# Why did we learn the plubming commands?

You will not typically use them on a day to day basis, but they are a good way to see what happens at the interim steps and make sure that you have the right understanding of what git does.  

A **correct** understanding is essential for using more advanced features


+++{"lesson_part": "site"}

I had an error in courseutils and did not get it fixed in time to use your action scripts.

:::::{exercise} 
:label: fixbadge

Navigate to your KWL repo and use [cspt](https://compsys-progtools.github.io/courseutils/examples/tasktracking.html) and `gh issue create` to make an issue for the review and/or practice badge for 2025-10-07.
:::{hint}
:class: dropdown

use `--help` on both `cspt getassignment` and `gh issue create` 

think about how to connect one command to another
:::
:::::::

:::::{solution} fixbadge
:class: dropdown

```
cspt getassignment --date 2025-10-07 --type review | gh issue create --title "Review 2025-10-07" --body-file - --label review
```

```
cspt getassignment --date 2025-10-07 --type practice | gh issue create --title "Pracitce 2025-10-09" --body-file - --label practice
```

::::::



+++{"lesson_part": "main"}

While there is of course some content that we want you to know after this course, my goal is also to teach you process, by modeling it.  

+++{"lesson_part": "main"}

No one will every know all of the things but you can be fast or slow at finding answers. 

And you can find correct answers, incorrect answers, or looks-okay-but-you-will-regret-this-later answers. 



+++{"lesson_part": "main"}

you do not want to become the colleague that everyone regrets working with


+++{"lesson_part": "main"}
## Today's Questions
- What are references?
- How can can I release and share my code?
- How else can git help me? 


+++{"lesson_part": "main","type":"heading"}
## What does git status do? 

_compares the working directory to the current state of the active branch_


- we cansee the working directory with: `ls`
- we can see the active branch in the `HEAD` file 
- what is its status? 


+++{"lesson_part": "main"}

Recall that we: 
- created a blob objct directly
- creataed a file
- hashed the file, to create its blob object
- added the file to the index
- wrote the tree
- created a commit

+++{"lesson_part": "site","type":"hint"}

````{margin}
```{hint}
For a community badge, make an item in the bulleted list here link to the sections of the notes from the last class using mystmd cross referencing. (credit for ones that have not been put in a PR)
```
````

+++{"lesson_part": "main"}

My goal is that you get good at *quickly* finding **correct** answers.  

Large language models will not do that for you.  



+++{"lesson_part": "main","type":"heading"}

## Tags

branches are not git objects, they are references.  

We can see that by where they are stored.


+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
cd test/
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
find .git/objects -type f
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
:label: objectlistc1
.git/objects/0c/1e7391ca4e59584f8b773ecdbbb9467eba1547
.git/objects/da/01135f2fb02e9b53c200708863df82f0daa50c
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
```

these 5 git objects refer to: 
- "test content"
- version 1 of test.txt
- version 2 of test.txt
- the tree
- the commit 

there is no object for the branch we have, main

+++{"lesson_part": "main"}

branches are only stored in the `refs` folder

```{code-cell} bash
:tags: ["skip-execution"]
ls .git/refs/
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
heads	tags
```



+++{"lesson_part": "main"}
the heads folder has only our one branch: 
```{code-cell} bash
:tags: ["skip-execution"]
ls .git/refs/heads/
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
main
```

+++{"lesson_part": "main"}

which is a pointer to the commit via its hash

```{code-cell} bash
:tags: ["skip-execution"]
cat .git/refs/heads/main 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
:label: commithash
da01135f2fb02e9b53c200708863df82f0daa50c
```
and we see the hash from the main branch
+++{"lesson_part": "main"}

The other type of git reference is called a tag. There are two types of tags: 

- a lightweight tag is like a branch that does not move
- an annotated tag is a git object, like a commit almost. 

+++{"lesson_part": "main"}
### View tags
The command `git tag` will list the current tags when used with no {term}`options <option>` or {term}`arguments <argument>`. 

```{code-cell} bash
:tags: ["skip-execution"]
git tag
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```
we have none so far, they don't get automatically created

+++{"lesson_part": "main"}

we can also check manually
```{code-cell} bash
:tags: ["skip-execution"]
ls .git/refs/tags/
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

+++{"lesson_part": "main"}
### Lightweight tags

Now, to make a tag we use `git tag <name of tag>` to create a lightweight tag
```{code-cell} bash
:tags: ["skip-execution"]
git tag v1
```



+++{"lesson_part": "main"}
and see what it did
```{code-cell} bash
:tags: ["skip-execution"]
git tag
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
v1
```

+++{"lesson_part": "main"}
 also manually how it implemented that
```{code-cell} bash
:tags: ["skip-execution"]
ls .git/refs/tags/
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
v1
```

+++{"lesson_part": "main"}
and check if it made an object: 
```{code-cell} bash
:tags: ["skip-execution"]
find .git/objects -type f
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
.git/objects/0c/1e7391ca4e59584f8b773ecdbbb9467eba1547
.git/objects/da/01135f2fb02e9b53c200708863df82f0daa50c
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
```

it did not! same 5 as before



+++{"lesson_part": "main"}
we can see the file
```{code-cell} bash
:tags: ["skip-execution"]
cat .git/refs/tags/v1 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
da01135f2fb02e9b53c200708863df82f0daa50c
```

this hash is the same as we saw above for [`main`](#commithash)


the lightweight tag is just like a branch, another pointer to the commit. 

The difference is that this does not move when we create new commits, so this is like a shortcut to a specific commit. 


+++{"lesson_part": "main"}
### Annotated tags

if we use the `-a` flag we get an annotated tag and we can add text to it with `-m` (like for a commit)

```{code-cell} bash
:tags: ["skip-execution"]
git tag -m 'annotated tag' -a v1.0.1
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```
again no output

+++{"lesson_part": "main"}
let's check the {term}`object database`: 

```{code-cell} bash
:tags: ["skip-execution"]
find .git/objects -type f
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
:linenos:
:emphasize-lines: 5
.git/objects/0c/1e7391ca4e59584f8b773ecdbbb9467eba1547
.git/objects/da/01135f2fb02e9b53c200708863df82f0daa50c
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579
.git/objects/73/0b071fd22aab21ddd8445522d4c4d49b9a3cc2
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
```

another object!  that `730b` was not there [before](#objectlistc1)

+++{"lesson_part": "main"}

let's inspect this too.  

it creates a file in the tags folder
```{code-cell} bash
:tags: ["skip-execution"]
cat .git/refs/tags/v1.0.1 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
730b071fd22aab21ddd8445522d4c4d49b9a3cc2
```

this has that new object hash we did not have before.  So the lightweight tag *only* points to a commit, but this created its own object to point to. 

+++{"lesson_part": "main"}

we can inspect that too: 
```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -p 730b
```

+++{"lesson_part": "main","type":"output"}


```{code-block} console
object da01135f2fb02e9b53c200708863df82f0daa50c
type commit
tag v1.0.1
tagger Sarah M Brown <brownsarahm@uri.edu> 1760029591 -0400

annotated tag
```

we see that it points to the commit hash and has information about the type, the name of the tag, author and the message we set. 

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -t 730b
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
tag
```


We can look at how [tags are represented on github](https://docs.github.com/en/repositories/releasing-projects-on-github/viewing-your-repositorys-releases-and-tags) in another repository. 

Tags enable {term}`release`s, where are [defined on github as](https://docs.github.com/en/repositories/releasing-projects-on-github/about-releases):

>Releases are deployable software iterations you can package and make available for a wider audience to download and use.


We can [create a relese for the tag we made](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository#creating-a-release)

## Making a second manual commit




+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   test.txt

no changes added to commit (use "git add" and/or "git commit -a")
```


+++{"lesson_part": "main"}
we can confirm we have this file already a blob for the current version: 
```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -p 0c1e
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
version 1
version 2
```

+++{"lesson_part": "main"}
then we need the full hash to make the tree so lets output the object list 
```{code-cell} bash
:tags: ["skip-execution"]
find .git/objects -type f
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
.git/objects/0c/1e7391ca4e59584f8b773ecdbbb9467eba1547
.git/objects/da/01135f2fb02e9b53c200708863df82f0daa50c
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579
.git/objects/73/0b071fd22aab21ddd8445522d4c4d49b9a3cc2
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
```

+++{"lesson_part": "main"}

again, we update the index
```{code-cell} bash
:tags: ["skip-execution"]
git update-index --add --cacheinfo 100644 \
> 0c1e7391ca4e59584f8b773ecdbbb9467eba1547
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console

error: option 'cacheinfo' expects <mode>,<sha1>,<path>
```

The first time I forgot the file name so we get an error saying that --cacheinfo requires 3 inputs, but I had only provded two. 

+++{"lesson_part": "main"}

we try again with the file name: 

```{code-cell} bash
:tags: ["skip-execution"]
git update-index --add --cacheinfo 100644 0c1e7391ca4e59584f8b773ecdbbb9467eba1547 test.txt
```

::::{embed} updateindexinfo
:::::

+++{"lesson_part": "main"}

we can confirm this worked with `git status`
```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   test.txt

```

+++{"lesson_part": "main"}
Now we can write the tree, which we need since commits point to trees. 

```{code-cell} bash
:tags: ["skip-execution"]
git write-tree
```


+++{"lesson_part": "main","type":"output"}

```{code-block} console
258231c1cee8048eef3a8057cfbdab76261277c6
```

+++{"lesson_part": "main"}

For any commit that is not the first, we also need the parent hash.  we have many ways we could find that, but we will use `log` this time. 
```{code-cell} bash
:tags: ["skip-execution"]
git log
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
commit da01135f2fb02e9b53c200708863df82f0daa50c (HEAD -> main, tag: v1.0.1, tag: v1)
Author: Sarah M Brown <brownsarahm@uri.edu>
Date:   Tue Oct 7 13:15:48 2025 -0400

    first commit
```

also note that the tags we made are visible here

+++{"lesson_part": "main"}

Now we can make the commit, from that tree, with parent `da01` 
```{code-cell} bash
:tags: ["skip-execution"]
echo "second commit" | git commit-tree 2582 -p da01
```
:::::{margin}
:::{important}
You need to use your first commit hash, not mine
:::
:::::

+++{"lesson_part": "main","type":"output"}

```{code-block} console
ae53600b5026c32ce0985fa9f31922db02fa2328
```

+++{"lesson_part": "main"}

:::::{exercise} 
:label:  status2

We have not yet done all of the steps that `git commit` would do.  What step is missing, can you do it?

::::{hint}
where is the HEAD pointer currently?
::::
:::::::

:::::{solution} status2
We need to write the hash of the second commit to the main file to put that commit on the main brach or to another file to make a new branch (and then set HEAD to that branch)
::::::


+++{"lesson_part": "main"}

## Stashing 

[git stash](https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning)

+++{"lesson_part": "main"}

Imagine you have worked on something part way, but not finished it, so you do not want to make a commit yet, but you need to switch and work on something else.  
+++{"lesson_part": "main"}

let's create such a scenario in our github inclass repo
```{code-cell} bash
:tags: ["skip-execution"]
cd ../gh-inclass-fa25-brownsarahm/
```


+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch organization
Your branch is up to date with 'origin/organization'.

nothing to commit, working tree clean
```


+++{"lesson_part": "main"}
We will add some new work to the README

```{code-cell} bash
:tags: ["skip-execution"]
echo " document new features " >> README.md 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch organization
Your branch is up to date with 'origin/organization'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
```

+++{"lesson_part": "main"}
If we want to switch branches now, 

```{code-cell} bash
:tags: ["skip-execution"]
git checkout main
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
error: Your local changes to the following files would be overwritten by checkout:
	README.md
Please commit your changes or stash them before you switch branches.
Aborting
```
we get an error


:::::{important}
this is git protecting you

`git checkout main` would:
- read the `.git/refs/heads/main` file 
- read the commit at that hash
- use the tree for that commit and write files reading from the blob objects and to the file names in the tree
- upate the HEAD pointer

this would include writing the `README` with the content as of our last commit on the main branch, and over writing the current version, so we would lose anything that has not been commited. 
:::::::
+++{"lesson_part": "main"}

`git stash`
stores temporary changes without making a commit so that we can come back to them. 


```{code-cell} bash
:tags: ["skip-execution"]
git stash
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Saved working directory and index state WIP on organization: e899a0e begin reorg
```

+++{"lesson_part": "main"}
we can see what we have stashed: 

```{code-cell} bash
:tags: ["skip-execution"]
git stash list
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
stash@{0}: WIP on organization: e899a0e begin reorg
```

+++{"lesson_part": "main"}
now we can switch

```{code-cell} bash
:tags: ["skip-execution"]
git checkout main
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Switched to branch 'main'
Your branch is up to date with 'origin/main'.
```


+++{"lesson_part": "main"}
and apply the changes
```{code-cell} bash
:tags: ["skip-execution"]
git stash apply
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
On branch main
Your branch is up to date with 'origin/main'.

Unmerged paths:
  (use "git restore --staged <file>..." to unstage)
  (use "git add <file>..." to mark resolution)
	both modified:   README.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	.secret

no changes added to commit (use "git add" and/or "git commit -a")
```
we got a merge conflict, but that is okay

+++{"lesson_part": "main"}

we can fix it
```{code-cell} bash
:tags: ["skip-execution"]
nano README.md 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

+++{"lesson_part": "main"}
then  add and commit
+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git add README.md 
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git commit -m 'doc new feats'
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
[main ff9fb6c] doc new feats
 1 file changed, 23 insertions(+)
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch main
Your branch is ahead of 'origin/main' by 1 commit.
  (use "git push" to publish your local commits)

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	.secret

nothing added to commit but untracked files present (use "git add" to track)
```


+++{"lesson_part": "main","type":"heading"}

## Git can help with Debugging

[chapter](https://git-scm.com/book/en/v2/Git-Tools-Debugging-with-Git)



+++{"lesson_part": "main"}
blame tells us who and when each line of  a file was last changed. 

```{code-cell} bash
:tags: ["skip-execution"]
git blame README.md 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
99f86bf7 (Sarah M Brown 2025-09-11 13:41:24 -0400  1) # GitHub practice
99f86bf7 (Sarah M Brown 2025-09-11 13:41:24 -0400  2) 
99f86bf7 (Sarah M Brown 2025-09-11 13:41:24 -0400  3) test
ff9fb6ce (Sarah M Brown 2025-10-09 13:24:28 -0400  4) 
ff9fb6ce (Sarah M Brown 2025-10-09 13:24:28 -0400  5) today is rainy
ff9fb6ce (Sarah M Brown 2025-10-09 13:24:28 -0400  6) |file | contents |
ff9fb6ce (Sarah M Brown 2025-10-09 13:24:28 -0400  7) > | --| -- |
ff9fb6ce (Sarah M Brown 2025-10-09 13:24:28 -0400  8) > | abstract_base_class.py | core abstract classes for the project |
ff9fb6ce (Sarah M Brown 2025-10-09 13:24:28 -0400  9) > | helper_functions.py | utitly funtions that are called by many classes |
ff9fb6ce (Sarah M Brown 2025-10-09 13:24:28 -0400 10) > | important_classes.py | classes that inherit from the abc |
ff9fb6ce (Sarah M Brown 2025-10-09 13:24:28 -0400 11) > | alternative_classes.py | classes that inherit from the abc |
ff9fb6ce (Sarah M Brown 2025-10-09 13:24:28 -0400 12) > | LICENSE.md | the info on how the code can be reused|
ff9fb6ce (Sarah M Brown 2025-10-09 13:24:28 -0400 13) > | CONTRIBUTING.md | instructions for how people can contribute to the project|
```

we can also view this with annotation and visually in GitHub


git will help you do a binary search to find what commit introduced a bug. 

+++{"lesson_part": "main"}
we have to tell it to start, then tell it that the current commit is bad, then tell it the last good commit (or a reference to it)

```
git bisect start
git bisect bad
git biset good <ref>
```




To do this we need to have to tell it what commit was good, this is one of the reasons that using tags can be helpful 


+++{"lesson_part": "main"}

 there are multiple ways to refer to a point in the history

[revision selection](https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection)



+++{"lesson_part": "main"}
First let's choose a point to use as our last good commit by scanning the previous commits. 


+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git log
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
commit ff9fb6ce0be3e0291dc34978c9e119bb94f79269 (HEAD -> main)
Author: Sarah M Brown <brownsarahm@uri.edu>
Date:   Thu Oct 9 13:24:28 2025 -0400

    doc new feats

commit 11017a59088d4a0b880f770f15fab8c9e086a789 (origin/main, origin/HEAD, mybranchcheckedoutb, my_branch)
Merge: c8f4926 99f86bf
Author: Sarah Brown <brownsarahm@uri.edu>
Date:   Tue Sep 16 19:51:36 2025 +0300

    Merge pull request #2 from compsys-progtools/1-add-a-readme
    
    create a readme closes #1

commit 99f86bf7112debc934e7fa4504232a48266d90e4 (origin/1-add-a-readme, 1-add-a-readme)
Author: Sarah M Brown <brownsarahm@uri.edu>
Date:   Thu Sep 11 13:41:24 2025 -0400

    create a readme closes #1

commit c8f4926313ba8f6c5bfad3857b7479a666328e6d
Author: github-classroom[bot] <66690702+github-classroom[bot]@users.noreply.github.com>
Date:   Thu Sep 11 14:49:01 2025 +0000

    Initial commit
```

+++{"lesson_part": "main"}
We will start `git bisect` first, this is our search for the "bad commit" 
```{code-cell} bash
:tags: ["skip-execution"]
git bisect start 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
status: waiting for both good and bad commits
```

+++{"lesson_part": "main"}

Now, lets tell it that the current commit is bad, this reprsents that we just rcevied the bug report. 
```{code-cell} bash
:tags: ["skip-execution"]
git bisect bad
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
status: waiting for good commit(s), bad commit known
```


now we get the updated status

+++{"lesson_part": "main"}
next we tell it what was the last known, not necessarily the last, good commit.  We'll use the about branch commit. This would represent a case where maybe we switched to to that branch locally, ran a test for the the new bug and it passed. 


```{code-cell} bash
:tags: ["skip-execution"]
git bisect good c8f4
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Bisecting: 0 revisions left to test after this (roughly 1 step)
[11017a59088d4a0b880f770f15fab8c9e086a789] Merge pull request #2 from compsys-progtools/1-add-a-readme
```

+++{"lesson_part": "main"}

Then we check each commit it checkout for us and label it as good or bad by seeing if the budg exists there. 

```{code-cell} bash
:tags: ["skip-execution"]
git bisect bad
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Bisecting: 0 revisions left to test after this (roughly 0 steps)
[99f86bf7112debc934e7fa4504232a48266d90e4] create a readme closes #1
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git bisect bad
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
99f86bf7112debc934e7fa4504232a48266d90e4 is the first bad commit
commit 99f86bf7112debc934e7fa4504232a48266d90e4 (HEAD, origin/1-add-a-readme, 1-add-a-readme)
Author: Sarah M Brown <brownsarahm@uri.edu>
Date:   Thu Sep 11 13:41:24 2025 -0400

    create a readme closes #1

 README.md | 3 +++
 1 file changed, 3 insertions(+)
 create mode 100644 README.md
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
cd ../test/
```

+++{"lesson_part": "main","type":"output"}


## Prepare for Next Class 

```{include} ../_prepare/2025-10-14.md
```

## Badges

`````{tab-set}
````{tab-item} Review
```{include} ../_review/2025-10-09.md
```

````

````{tab-item} Practice
```{include} ../_practice/2025-10-09.md
```

````
`````



## Experience Report Evidence

## Questions After Today's Class 