---
kernelspec:
    name: python3
---

# How does a computer represent non integer quantities?

## Fixed Point 



We practices translating some numbers using a fixed point representation with 8 bits, so there are 8 places 
### Places
(eight)= 
#### Eights
$$2^3 = 8$$


(four)= 
#### Fours
$$2^2 = 4$$

(two)= 
#### Twos
$$2^1 = 2$$

(one)= 
#### Ones
$$2^0 = 1$$

(half)= 
#### Halves
$$2^{-1} = \frac{1}{2}$$

(quarter)= 
#### Quarters
$$2^{-1} = \frac{1}{4}$$

(eighth)= 
#### Eighths
$$2^{-1} = \frac{1}{8}$$

(sixteenth)= 
#### Sixteenths
$$2^{-1} = \frac{1}{16}$$

### Example numbers in Fixed point 
#### 1.5 


[0](#eight)[0](#four)[0](#two)[1](#one).[1](#half)[0](#quarter)[0](#eighth)[0](#sixteenth)

or: 
$$ 0*2^3 + 0*2^2 + 0*2^1 + 1*2^0 + 1*2^{-1} + 0*2^{-1} + 0*2^{-1} + 0*2^{-1} =$$ 
$$0*8 + 0*4 +0*2 + 1*2 + 1*\frac{1}{2} + 0* \frac{1}{4} + 0*\frac{1}{8} + 0*\frac{1}{16}=$$ 
$$ 1 + .5 $$
####  12.75
> 1100.1100

[1](#eight)[1](#four)[0](#two)[0](#one).[1](#half)[1](#quarter)[0](#eighth)[0](#sixteenth)

or: 
$$ 1*2^3 + 1*2^2 + 0*2^1 + 0*2^0 + 1*2^{-1} + 1*2^{-1} + 0*2^{-1} + 0*2^{-1} =$$ 
$$ 1*8 + 1*4 +0*2 + 0*1 + 1*\frac{1}{2} + 1* \frac{1}{4} + 0*\frac{1}{8} + 0*\frac{1}{16}=$$ 
$$ 8+4 + .5 + .25$$
#### 7.5625
> 0111.1001

[0](#eight)[1](#four)[1](#two)[1](#one).[1](#half)[0](#quarter)[0](#eighth)[1](#sixteenth)

or: 
$$ 0*2^3 + 1*2^2 + 1*2^1 + 1*2^0 + 1*2^{-1} + 0*2^{-1} + 0*2^{-1} + 1*2^{-1} =$$ 
$$ 0*8 + 1*4 +1*2 + 1*1 + 1*\frac{1}{2} + 0* \frac{1}{4} + 0*\frac{1}{8} + 1*\frac{1}{16}=$$ 
$$ 4+2+1 + .5 + 0625$$
#### 15.9375:

 [1](#eight)[1](#four)[1](#two)[1](#one).[1](#half)[1](#quarter)[1](#eighth)[1](#sixteenth)

or: 
$$ 1*2^3 + 1*2^2 + 1*2^1 + 1*2^0 + 1*2^{-1} + 1*2^{-1} + 1*2^{-1} + 1*2^{-1} = $$ 
$$1*8 + 1*4 +1*2 + 1*2 + 1*\frac{1}{2} + 1* \frac{1}{4} + 1*\frac{1}{8} + 1*\frac{1}{16}= $$ 
$$8+4+2+1 + .5+ .25+ .125 + 0625$$


## Prelude

What do we mean by representation?


Computers are electrical devices, there are circuits that calculate everything, using gates that represent logical operations.  

In order to get the data (the thigns we want to compute) through the ciruits we have to *represent* the values somehow. 


We discussed [previously](#01hash) how we could represent success/failure with 0/1.

You may have seen ASCII codes before: those are numbers to represent each character, that is how characters are represented in a computer. 

+++{"lesson_part": "main"}

Sometimes, we *mix* representations within a single bit string: 
- object instructions could use the first few bits to represent the operation and the rest to represent a value (so we can encode an instruction in a single register)
- negative numbers (the first bit is sign and the rest represent places)

+++{"lesson_part": "main"}
### a toy object instruction

let say we have am CPU that can do 4 bit operations and has 4 control bits (that determine what operation it will do across the ALU + controls for A,D registers & PC)


then we might have an 8 bit register ROM.

the operation `@3` might represented as `01000011` if `@` is indicated by `0100` on the controler and then the last 4 bits `0011` represent the value 3



+++{"lesson_part": "site"}

### negative numbers
we use one bit to represent the sign.  and then e have two choices for the rest of the bits: 

+++{"lesson_part":"site","type":"table"}

```{list-table}

* - representation
  - how to negate
  - how to read
* - one's complement
  - flip all the bits
  - note the sign, flip all the bits back
* - two's complement
  - flip the bits, add 1
  - note the sign, flip all the bits, add one
```

+++{"lesson_part": "main"}
Try it out on [integer exposed](https://integer.exposed/)

For example, set it to [3](https://integer.exposed/#0x03) and then use the `~` button to flip the bits and add one by flipping the 0 in the ones place to a 1 (add one), that ends up at [-3](https://integer.exposed/#0xfd)

so in 8 bit signed integer 3 is 00000011 and -3 is 11111101.

Try a few other cases in [integer exposed](https://integer.exposed/)

Two's complement is themost common



+++{"lesson_part": "main","type":"heading"}



## Floating Point Notation



+++{"lesson_part": "main"}



We can write  numbers in many different forms. We have written integers through many different bases so far.



+++{"lesson_part": "main"}


For example in scientific contexts, we often write numbers (in base 10) like:




+++{"lesson_part": "main"}


$$
3.45 \times 10^2 = 345
$$





+++{"lesson_part": "main"}


We can use a similiar form to represent numbers in binary. Using base 2 instead of base 10.  




+++{"lesson_part": "main","type":"heading"}



## Floating point numbers are not all  exact



+++{"lesson_part": "main"}


Let's look at an example, we add `.1` together 3 times, and we get the expected result.

+++{"lesson_part": "main","type":"output"}
We'll use python here, but you can do this in any programming language. 
```{code-cell} python
.1+.1 +.1
```


However, if we check what it's equal to, it does not equal .3

```{code-cell} python
.1 + .1 + .1 == .3
```

+++{"lesson_part": "main"}


This is because the floating point representation is an *approximation* and there are multiple full numbers that are close to any given number that cannot be expressed exactly.
However, the display truncates since usually we want only a few significant digits.  
Even rounding does not make it work.
+++{"lesson_part": "main"}

```{code-cell} python
round(.1,1) + round(.1,1) + round(.1,1) == round(.3,1)
```


+++{"lesson_part": "site"}

:::::{important}
This matters because we cannot rely on equality tests for floats
:::::

Instead, we use subtraction and a tolerance:

```{code-cell} python
(.1+.1+.1 - .3)< .0001
```

<!-- #region -->
## Floating point IEEE standard




+++{"lesson_part": "main"}


Now, lets see how these numbers are actually represented.


[float.exposed](https://float.exposed/0x2b3c3a80)

+++{"lesson_part": "main"}


[IEEE Floating Point ](https://ieeexplore.ieee.org/document/8766229)
is what basically everyone uses, but it is technically a choice hardware manufacturers can  make.


- Initially in 1985
- Reviesd in 2008 after 7 year process that expanded
- revised in 2019 after 4 year process that mostly added clarifications
- Next revision is projected to 2028.


+++{"lesson_part": "site"}

```{note}
IBM mainframes use their own representiton based on Hex*

```

+++{"lesson_part": "main"}


this is a double precision float or binary64 inthe current standard.  



+++{"lesson_part": "main"}


it was called double in the original, offically, so it is commonly called that still, even though it is no longer the formally correct name.


+++{"lesson_part": "main"}


In this case we will 1 bit for sign, 11 for exponent and 52 for the fraction part



+++{"lesson_part": "main"}

:::::::{attention}
I know this image does not work well in dark mode. 
If you [help fix it](https://mystmd.org/guide/website-style#light-dark-css), you can earn a community badge. 
::::::::


::::::{figure} https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/IEEE_754_Double_Floating_Point_Format.svg/2560px-IEEE_754_Double_Floating_Point_Format.svg.png
:label: floatbits
:alt: 64 total small rectangles in a horizontal line to represent 64 bits, 1 in light blue labeled sign, 11 in green labeled exponent, and 52 in red labeled fraction

a visual representation of a 64 bit float:
- the first bit is the {term}`sign bit`
- the next 11 bits are the {term}`exponent`
- the 52 bits of the {term}`fraction` are numbered from right to left  (the rightmost is $b_0$ and the leftmost is $b_{51}$).
:::::::::

+++{"lesson_part": "main","type":"heading"}

### How do we read a number like this?



+++{"lesson_part": "main"}


if the sign bit is $s$ and the number represented by the exponent bits is $e$ and the 52 bits are number from right most is 0 and the last one is 52.



+++{"lesson_part": "site"}



```{math}
:label: floatstd
(-1)s + \left(1 + \sum_{i=1}^{52} b_{52-i} 2^{-i}\right) \times 2^{e-1023}
```

where: 
(floatstddef)=
- $s$ is the sign bit is
- $e$  is the number represented by the exponent bits is and
- the 52 bits of the fraction are numbered from right to left  (the rightmost is $b_0$ and the leftmost is $b_{51}$).
-  $2^{-i}$ means we are working with *fractions* instead of integers in the sum.
- $\sum_{i=1}^{52}$ means the sum for $i = 1, 2, \ldots, 52$

+++{"lesson_part": "main"}


So, for example: 


```{code-block} console
:label: bitsfloat1
0 01111111111 0000000000000000000000000000000000000000000000000000
```

we have $s=0$ and $e=1023$ and all of the $b_i=0$. 

we can follow the [equation](#floatstd), and [interpret the bits](#floatstddef) to get:

```{math}
:label: mathfloat1
(-1)*0 + \left(1 + 0 \cdot 2^{-0} + 0 \cdot 2^{-1} + \ldots  + 0 \cdot 2^{-51} + 0 \cdot 2^{-52} \right) \times 2^{1023-1023} \\
= 0 + (1 + 0) \times 2^0  \\
= 1 \times 1 =  1.0
```


+++{"lesson_part": "main"}

and for 
```{code-block} console
:label: bitsfloatpt25
0 01111111111 0100000000000000000000000000000000000000000000000000
```



+++{"lesson_part": "site"}
we have $s=0$ and $e=1023$ and all of the $b_i=0$, except $b_50$. 
following the [equation](#floatstd), we get: 

```{math}
:label: mathfloat1pt25
(-1)*0 + \left(1 + 0\cdot 2^{-1} + 1\cdot 2^{-2} + 0\cdot 2^{-3}  + \ldots  + 0\cdot 2^{-51} + 0\cdot 2^{-52} \right) \times 2^{1023-1023} \\
 = 0 + (1 + \frac{1}{4}) \times 2^0  \\ = 1.25 \times 1 =  1.25 
```



+++{"lesson_part": "main"}

### Why use e-1023 for the exponent?


```{code-cell} python
2**11
```

so 1023 is half -1, this means that we split the possible range of numbers that we can represent in the exponent to positive and negative, meaning the whole expression $2^{e-1023}$ ranges from large($2^{1025}$) to small($2^{-1023}$) 


+++{"lesson_part": "main","type":"heading"}



### How do we get numbers into this form?



+++{"lesson_part": "main"}


Now, let's return to our example of .1.



+++{"lesson_part": "main"}


First we take the sign of the number for the sign bit, but then to get the exponent and fraction, we have more work to do.  



+++{"lesson_part": "main"}


Let's take the equation we had from the standard:



$$  \left(1 + \sum_{i=1}^{52} b_{52-i} 2^{-i}\right) \times 2^{e-1023}$$
<!-- #endregion -->



+++{"lesson_part": "main"}



If we think about the fraction and how we add fractions, by reaching a common denominator. Since they're all powers of two, we can use the last one.    


$$  \left(1 + \sum_{i=1}^{52} b_{52-i} 2^{-i}\right) \times 2^{e-1023}$$




+++{"lesson_part": "main"}

and we can expand the sum to a different notation for visual clarity

$$ \left( 1 + \frac{b_{52}}{2^{1}} + \frac{b_{51}}{2^{2}} + \cdots + \frac{b_{1}}{2^{51}} + \frac{b_{0}}{2^{52}} \right) \times 2^{e-1023} $$




+++{"lesson_part": "main"}


And apply a common denominator:




$$ \left(\frac{2^{52}}{2^{52}} + \frac{2^{51} b_{52}}{2^{52}} + \frac{2^{50} b_{51}}{2^{52}} + \cdots + \frac{2^{1} b_{1}}{2^{52}} + \frac{2^0 b_{0}}{2^{52}}  \right) \times 2^{e-{1023}} $$



+++{"lesson_part": "main"}


So then this becomes a binary number with 53 bits (the 52 + 1) and a denominator of $2^{52}$, let's call that number $J$ so we have:.


$$ \frac{J}{2^{52}}  \times 2^{e-{1023}} $$



+++{"lesson_part": "main"}


we can then combine the powers of 2.

$$ \frac{J}{2^{52-e+1023}} =  \frac{J}{2^{N}}  $$


+++{"lesson_part": "main"}


So in order to return to our `.1` that we want to represent, we can represent it as a fraction and then approximated it in the form above.



$$\frac{1}{10} \approx \frac{ J }{2^N}$$


$\approx$  means approximately equal to



+++{"lesson_part": "main"}

after some manipulation:

```{math}
:label: jdef
J \approx 2^N / 10
```




+++{"lesson_part": "main"}


Since we want to use exactly 53 bits to represent $J$, we want $\frac{2^N }{10}$ to be greater than or equal to $2^{52}$ and less than $2^{53}$.



```{math}
:label: ineqmain
2^{52} <= \frac{2^N }{10} < 2^{53}
```



+++{"lesson_part": "main"}

Since $8<10<16$ we can say $2^3<10<2^4$

and  we can also say that 

$$ \frac{1 }{2^4} < \frac{1 }{10} < \frac{1 }{2^3} $$ 

(larger denominators is smaller numbers if the numerators are the same) 



+++{"lesson_part": "main"}

We can put any numerator that is the same across all : 
 $$ \frac{2^N }{2^4} < \frac{2^N }{10} < \frac{2^N }{2^3} $$


+++{"lesson_part": "main"}

and simplify the outer ones to only have a single exponent

```{math}
:label:ineqN34
2^{N-4} <  \frac{2^N }{10} < 2^{N-3}
```


+++{"lesson_part": "main"}

If we combine [](#ineqN34) with our previous inequality from  [](#ineqmain), we can see that the best $N$ is 56, by taking either side $N-4=52$ or $N-3=53$. 

+++{"lesson_part": "main"}

We can confirm this in a calculator

```{code-cell} python
2**52 <=2**56/10 < 2**53
```


+++{"lesson_part": "main"}


Now we can get the number we will use for $J$, from [](#jdef). 

We want to get as close to .1 with our fraction as possible, so
we get the quotient and remainder, the quotient will be the number we use, but we use the remainder to see if we round up or not



```{code-cell} python
q,r = divmod(2**56, 10)
```

Now,  we check the remainder to decide if we should round up by 1 or not.


```{code-cell} python
r
```


+++{"lesson_part": "main"}


$ 6 > 5 = \frac{10}{2}$  so we round up


```{code-cell} python
J = q+1
J
```

+++{"lesson_part": "main"}


then we can check the length in bits of that number
```{code-cell} python
bin(J)
```
we could count above, or since there are 2 extra characters to tell us it is binary at the start we can take the `len` and subtract 2: 

```{code-cell} python
len(bin(J) )-2
```

This is, as expected 53 bits!

The significand is actually 52 bits though, the representation just always has a 1 in it, see the 1 added before the sum of the bits in [](#floatstd) or on [float.exposed](https://float.exposed/0x3ff0000000000000) when the exponent is 1023 (the green bits; so that the multiplicative part of [](#floatstd) is $2^{1023-1023} = 2^0 = 1$ ) and the significand is 0(the blue bits)

```{code-cell} python
significand = J-2**52
significand
```


+++{"lesson_part": "main"}



We have  $N = 56 = 52-e+1023$ so to solve for $e$ we get $e= 52-56+1023$


```{code-cell} python
e = 52-56+1023
e
```


+++{"lesson_part": "main"}

Now lets' confirm what we found with the actual representation: 

First we can plug into [float.exposed](https://float.exposed/0x3fb999999999999a) and see that is very clsoe to .1 and if we increase the significand at all it gets farther away. 


Second, we can check in Python. 
Python doesn't provide a binary reprsentation of floats, but it does provide a hex representation.


```{code-cell} python
float.hex(.1)
```

- the `0x` can be dropped from reading
- after the p is the exponent of $-4 = 1019-1023$. Which matches the approximation we found.  
- the rest we can compare to the value we found for J

```{code-cell} python
hex(J)
```



+++{"lesson_part": "main"}

Third, we can test by computing the approximation: 

```{code-cell} python
(J)/2**56 ==.1
```

We can also see how close the numbers one above and one below are: 

```{code-cell} python
(J-1)/2**56 - .1
```

```{code-cell} python
(J+1)/2**56 - .1
```

these are the closest numbers we can represent to .1 meaning we, for example cannot represent $.1 \pm 1.2e-18$ 

```{code-cell} python
.1 - 1.2*10**-18
```

```{code-cell} python
.1 + 1.2*10**-18
```

If we add these tiny values it does not change the value at all.  

```{code-cell} python
.1 - 1.2*10**-18 ==.1
```

The same thing happens for very large numbers, [4503599627370496](https://float.exposed/0x4330000000000000) is the beginning of a range in float64 where the closest numbers we can represent are 1 apart, so for example: 

```{code-cell} python
4503599627370496.0 +.5
```
doesn't work;  it cannot represent `4503599627370496.5`
:::::{seealso}
See on [float.exposd](https://float.exposed/0x4330000000000000) by increasing the significand by 1 at a time
::::::::

Above [9007199254740992](https://float.exposed/0x4340000000000000) we cannot even represent odd integers, only even for a while and then it gets more and more sparse. 
```{code-cell} python
9007199254740992.0 +1
```

::::::{figure} https://wizardzines.com/images/uploads/the-floating-point-number-line.png

The floating point number line is not uniform. 
[source](https://wizardzines.com/comics/the-floating-point-number-line/)
::::::::::
+++{"lesson_part": "main"}


+++{"lesson_part": "main","type":"output"}




## Prepare for Next Class 

```{include} ../_prepare/2025-10-23.md
```

## Badges

`````{tab-set}
````{tab-item} Review
```{include} ../_review/2025-10-21.md
```

````

````{tab-item} Practice
```{include} ../_practice/2025-10-21.md
```

````
`````



## Experience Report Evidence

## Questions After Today's Class 