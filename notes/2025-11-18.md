---
file_format: mystnb
kernelspec:
    name: python3
---

# How does timing work in a computer?



+++{"lesson_part": "main","type":"heading"}

## Von Neumann Architecture


+++{"lesson_part": "main"}

![von Neumann Architecture](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/Von_Neumann_Architecture.svg/2560px-Von_Neumann_Architecture.svg.png)


+++{"lesson_part": "main"}

We have talked about the ALU at length and we have touched on memory, but next we will start to focus on the Control unit.



+++{"lesson_part": "main"}

We discussed that the operations we need to carry out is mostly


+++{"lesson_part": "main","type":"heading"}


## Control Unit



+++{"lesson_part": "main"}

The control unit converts binary instructions to signals and timing to direct the other components.




+++{"lesson_part": "main","type":"heading"}

###  What signals?


+++{"lesson_part": "main"}

We will go to the ALU again since the control unit serves it to figure out what it needs.  
Remember in the ALU, has input signals that determine which calculation it will execute based on the input.

[8bit ALU](https://lodev.org/logicemu/#id=alu)


+++{"lesson_part": "main","type":"heading"}


### Why Timing signals?



+++{"lesson_part": "main"}

Again, the ALU itself tells us why we need this, we saw that different calculations the ALU does take different amount of times to propagate through the circuit.


+++{"lesson_part": "main"}

Even adding numbers of different numbers that require different number of carries can take different amount of times.


+++{"lesson_part": "main"}

So the control unit waits an amount of time, that's longer than the slowest calculation before sending the next instruction.  It also has to wait that long before reading the output of the ALU and sending that result to memory as needed.  


+++{"lesson_part": "main","type":"heading"}

## What is a clock?



+++{"lesson_part": "main"}

In a computer the clock refers to a clock signal, historically this was called a logic beat. This is represented by a sinusoidal (sine wave) or square (on, off, on, off) signal that operates with a constant frequency.  


+++{"lesson_part": "main"}

This has changed a lot over time.  



+++{"lesson_part": "main"}


The first mechanical analog computer, the Z1 operated at 1 Hz, or one cycle per second; its most direct successor moved up to 5-10Hz; later there were computers at 100kHz or 100,000Hz, but where one instruction took 20 cycles, so it had an effective rate at 5kHz.


+++{"lesson_part": "site"}

:::::{exercise} Find your speed
Look up the CPU speed of your computer and your phone. How do they compare.
::::::


## Execution Times


We will go to our clones of the course website repo:

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
cd fall2025/
```


+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
_data			faq			notes
_lab			files.sh		README.md
_practice		genindex.md		references.bib
_prepare		img			requirements.txt
_review			index.md		resources
_static			LICENSE			syllabus
_worksheets		local.sh		systools-fav.ico
activities		myst.yml		systools.png
```

+++{"lesson_part": "main"}

How many glossary terms are used per class session
```{code-cell} bash
:tags: ["skip-execution"]
grep term notes/*
```

:::::{tip}
In class i forgot the `-c` option to get counts instead of just finding them. 
:::::::

:::::{warning}
Long output is removed
::::::

This code read each individual file, found all instances of `term` 


+++{"lesson_part": "main"}
We can get the computer to time it for us with `time`
```{code-cell} bash
:tags: ["skip-execution"]
time grep term notes/*
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console


real	0m0.015s
user	0m0.009s
sys	0m0.004s
```
:::::::{margin}
:::::{warning}
Long output is removed
::::::
:::::::::::

+++{"lesson_part": "main"}
and at the bottom we see the timing results. 


+++{"lesson_part": "main"}

(threetimes)=
### Three types of time

- real: wall clock time, the total time that you wait for the the process to execute
- user: CPU time in user mode within the the process, the time the CPU spends executing the process itself
- sys: CPU time spent in the kernel within the process, the time CPU spends doing operating system interactions associated with the process



+++{"lesson_part": "main"}

The real time includes the user time, the system time, and any scheduling or waiting time that that occurs.  


We can do this a bunch of times to compare how the times vary: 

+++{"lesson_part": "main"}
::::::::{tab-set}
:::{tab} 1
```{code-cell} bash
:tags: ["skip-execution"]
time grep term notes/*
```


```{code-block} console


real	0m0.022s
user	0m0.009s
sys	0m0.007s
```
::::
::::{tab} 2

```{code-cell} bash
:tags: ["skip-execution"]
time grep term notes/*
```



```{code-block} console


real	0m0.015s
user	0m0.007s
sys	0m0.007s
```
::::
::::{tab} 3

```{code-cell} bash
:tags: ["skip-execution"]
time grep term notes/*
```



```{code-block} console


real	0m0.016s
user	0m0.009s
sys	0m0.007s
```

::::
::::{tab}  4

```{code-cell} bash
:tags: ["skip-execution"]
time grep term notes/*
```



```{code-block} console


real	0m0.014s
user	0m0.009s
sys	0m0.003s
```

::::
::::{tab} 5

```{code-cell} bash
:tags: ["skip-execution"]
time grep term notes/*
```



```{code-block} console


real	0m0.018s
user	0m0.009s
sys	0m0.008s
```
::::
::::{tab} 6

```{code-cell} bash
:tags: ["skip-execution"]
time grep term notes/*
```

```{code-block} console


real	0m0.016s
user	0m0.009s
sys	0m0.006s
```
::::
::::::::::

Notice: 
- the `user` time is more consistent tha the others
- the `real` time that has the most external factors varies the most
- the `sys` time varies more than `user` and less than `real`


::::::{exercise}
:label: comparetimes

Which of the [three times](#threetimes) is the one you have the most control over as the developer of an individual program? 

:::::::

::::{solution} comparetimes
:class: dropdown

the `user` time
::::::


::::::{exercise}
:label: longreal

If you are working on some code and it is taking a long time to run in your manual tests and you use `time` and see that the `real` time is a lot longer than the sum of the `user` and `sys` times, what might you do? 

:::::::

::::{solution} longreal
:class: dropdown

Consider closing other programs that are running on your computer, the problem is not related to your code
::::::



::::::{exercise}
:label: longsys

If you are working on some code and it is taking a long time to run in your manual tests and you use `time` and see that the `sys` time is a large percentage of the time.  What kinds of things in your code would you want to work on? 

:::::::

:::::::::{solution} longsys
:class: dropdown

Check for operating system related actions, for example writing and reading files.  


As a quick proof of concept compare the following two actions:

:::::{tab-set}
:::{tab} No file writing
```{code-cell} bash
:tags: ["skip-execution"]
time for i in {1..1000}; do echo 'hello'; done | wc -l
```
:::
:::{tab} With file writing
```{code-cell} bash
:tags: ["skip-execution"]
time for i in {1..1000}; do echo 'hello' >greet.txt; done | wc -l
```
:::
::::::

::::::::::

See the timing example in the notes of the last class too! 

In the [](#addspeed) [solution](#addspeedsoln)


+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]

```




## Prepare for Next Class 

```{include} ../_prepare/2025-11-20.md
```

## Badges

`````{tab-set}
````{tab-item} Review
```{include} ../_review/2025-11-18.md
```

````

````{tab-item} Practice
```{include} ../_practice/2025-11-18.md
```

````
`````



## Experience Report Evidence

## Questions After Today's Class 


### Is it possible to turn the clock off and how badly would that damage the computer?

The CPU literally cannot function without it. 

### Is the clock supposed to "tick" at a constant interval? If so, how does it do it?

yes! 

Currently, the typical implementation is (possibly all, but I am not super confident on that) uses a component called an <wiki:Crystal_oscillator>.  This is a physical device that naturaly produces a fixed frequency sine wave. You can read more inthe <wiki:Clock_rate#Engineering>. 

### Why canâ€™t the computer skip ahead when the add is fast?


Theoretically, it could be designed to do that, but there would need to be extra logic encoded in the device in order to catch that.  This is non trivial and since the "ticks" are so fast (GHz=billions per second) we decide to save space on the board for other things (like more ALUs) or save money in prodcing it or give more unused space to dissipate heat better instead of this choice

::::{tip}
It could be an explore badge to try to implement this in logicemu. 

:::::