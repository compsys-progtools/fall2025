---
file_format: mystnb
kernelspec:
    name: python3
---


# How does git make a commit?



+++{"lesson_part": "main"}


Today we will dig into how git *really* works.  This will be a deep dive and provide a lot of details about how git creates a commit.  It will reinforce important **concepts**, which are of practical when using git.  

:::{important}
Part of today's goal is to help make sure that you do not have misconceptions about git. 
::: 

You could use the basic commands without understanding how it works, or with even an incorrect understanding.  However, to really get the most important advantages out of git and use it fluently, know how it works in great detail is a huge advantage.  


+++{"lesson_part": "main"}

Today is also an exercise in careful examination of a system. You will do this a lot in your career, whenever you are debugging something, being able to systematically break it down and examine all of the parts is the central skill. 


+++{"lesson_part": "main"}


Later, we will build on this more on the practical side, but these **concepts** are very important for making sense of the more practical aspects of fixing things in git.  


+++{"lesson_part": "main"}


This deep dive in git is to help you build a correct, flexbile understanding of git so that you can use it independently and efficiently. The plumbing commands do not need to be a part of your daily use of git, but they are the way that we can dig in and see what *actually* happens when git creates a commit. 


+++{"lesson_part": "main"}
 
:::{tip}
this is also to serve as an example method you could apply in understanding another complex system
:::

Inspecting a system's components is a really good way to understand it and correctly understanding it will impact your ability to ask good questions and even look up the right thing to do when you need to fix things. 


+++{"lesson_part": "main"}

## Outcomes for today

Also, looking at the parts of git is a good way to reinforce specific design patterns that are common in CS in a practical way.  This means that today we will also: 
- review and practice with the bash commands we have seen so far
- see a practical example of hashing
- reinforce through examples what a pointer does

## Review

+++{"lesson_part": "main"}
Recall: git stores important content in *files* that it uses like variables. 


navigate to your github inclass repo
```{code-cell} bash
:tags: ["skip-execution"]
cd gh-inclass-fa25-brownsarahm/
```



+++{"lesson_part": "main"}

Some files in git work like pointers: 

```{code-cell} bash
:tags: ["skip-execution"]
cat .git/HEAD 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
ref: refs/heads/organization
```
holds the current branch 
+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
ls .git
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
COMMIT_EDITMSG	hooks		ORIG_HEAD
config		index		packed-refs
description	info		REBASE_HEAD
FETCH_HEAD	logs		refs
HEAD		objects
```

+++{"lesson_part": "main"}


`.gitignore` is a file in the working direcotry that contains alist of files and patterns to not track. 

We can see it is a hidden file in the working directory with `ls -a`

```{code-cell} bash
:tags: ["skip-execution"]
ls -a
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
.			docs
..			example.md
.git			helper_functions.py
.github			important_classes.py
.gitignore		LICENSE.md
.secret			README.md
abstract_base_class.py	scratch.ipynb
alternative_classes.py	setup.py
API.md			tests
CONTRIBUTING.md
```

+++{"lesson_part": "main","type":"heading"}

## Creating a repo from scratch


+++{"lesson_part": "main"}

We will start in the top level course directory.
+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
cd ..
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
fall25-kwl-brownsarahm
gh-inclass-fa25-brownsarahm
tiny-book
```

Yours should also have your kwl repo, gh inclass repo, course website clone, etc.  

+++{"lesson_part": "main"}

We can confirm that we are not in a git repository already: 

```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
fatal: not a git repository (or any of the parent directories): .git
```

::::{warning}
If you were in a repo and have repos in repos, you should use office hours to get that sorted out
::::


+++{"lesson_part": "site"}

We can create an empty repo from scratch using `git init <path>`

Last time we used an existing directory like `git init .` because we were working in the directory that already existed


+++{"lesson_part": "main"}


Today we will create a new directory called `test` and initialize it as a repo at the same time:

```{code-cell} bash
:tags: ["skip-execution"]
git init test
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
hint: Using 'master' as the name for the initial branch. This default branch name
hint: is subject to change. To configure the initial branch name to use in all
hint: of your new repositories, which will suppress this warning, call:
hint:
hint: 	git config --global init.defaultBranch <name>
hint:
hint: Names commonly chosen instead of 'master' are 'main', 'trunk' and
hint: 'development'. The just-created branch can be renamed via this command:
hint:
hint: 	git branch -m <name>
Initialized empty Git repository in /Users/brownsarahm/Documents/inclass/systems/test/.git/
```
:::::{margin}
:::{note}
[we get this message again, see context from last week](nomaster)
:::
:::::


+++{"lesson_part": "main"}
First we go into that directory: 
```{code-cell} bash
:tags: ["skip-execution"]
cd test/
```


+++{"lesson_part": "main"}

I will change mine manually so that I keep getting the warning to teach about it. 


```{code-cell} bash
:tags: ["skip-execution"]
git branch -m main
```



+++{"lesson_part": "main"}
To confirm we will look at the status
```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch main

No commits yet

nothing to commit (create/copy files and use "git add" to track)
```

Notice that there are no commits, and no origin. 

+++{"lesson_part": "main"}

## Examining an empty repo 

```{code-cell} bash
:tags: ["skip-execution"]
ls .git
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
config		hooks		refs
description	info
HEAD		objects
```
we can see the basic requirements of an empty repo here. 



+++{"lesson_part": "main"}
We can also see the basic configurations: 

```{code-cell} bash
:tags: ["skip-execution"]
cat .git/config 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
	ignorecase = true
	precomposeunicode = true
```

+++{"lesson_part": "main"}

## Searching the file system


We can use the bash command `find` to search the file *system* note that this does not search the **contents** of the files, just the names.

```{code-cell} bash
:tags: ["skip-execution"]
find .git/objects/
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
.git/objects/
.git/objects/pack
.git/objects/info
```



we have a few items in that directory and the directory itself.

+++{"lesson_part": "main"}

We can limit by type, to only files with the `-type` option set to `f`

```{code-cell} bash
:tags: ["skip-execution"]
find .git/objects/ -type f
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```


And we have no results. We have no objects yet. Because this is an empty repo 



+++{"lesson_part": "site"}
## Git Objects

Remember our 3 types of objects
- blob objects: the content of your files (data)
- tree objects: stores file names and groups files together (organization)
- Commit Objects: stores information about the sha values of the snapshots



```{mermaid}

classDiagram
    class tree{
    List: 
      - hash: blob
      - string: type
      - string:file name 
    }
    class commit{
        hash: parent
        hash: tree
        string: message
        string: author 
        string: time
    }
    class blob{
        binary: contents
    }
    class object{
        hash: name

    }
    object <|-- blob
    object <|-- tree
    object <|-- commit
```



+++{"lesson_part": "main","type":"heading"}

### How to create an object



+++{"lesson_part": "main"}

All git objects are files stored with the name that is the hash of the content in the file




+++{"lesson_part": "main"}

Remember git is a content-addressable file systsem... so it uses key- value pairs. 




+++{"lesson_part": "main"}

Let's create our first git object.  git uses hashes as the key. We give the hashing function some content, it applies the algorithm and returns us the hash as the reference to that object.  We can also write to our .git directory  with  this.



+++{"lesson_part": "main"}

The `git hash-object` command works on files, but we do not have any files yet.  We can create a file, but we do not have to.  Remememer, **everything** is a file. 


+++{"lesson_part": "main"}
When we use commands like `echo` it writes to the stdout file. 

```{code-cell} bash
:tags: ["skip-execution"]
echo "test content"
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
test content
```
which shows on our terminal. We can us a pipe to connect the stdout of on command to the stdin of the next. 
+++{"lesson_part": "main"}

pipes (`|`) are an important content too. we're seeing them in context of real uses, and we will keep seing them. Pipes connect the std out of one command t othe std in of the next.
+++{"lesson_part": "main"}

We can put these together: 
```{code-cell} bash
:tags: ["skip-execution"]
echo "test content" | git hash-object --stdin
```



We can break down this command: 
- `git hash-object` would take the content you handed to it and  return the unique key
- `--stdin` option tells `git hash-object` to get the content to be processed from stdin instead of a file
- the `|` is called a pipe (what we saw before was a redirect) it pipes a _process_ output into the next command
- `echo` would write to stdout, with the pipe it passes that to std in of the `git hash-object`



+++{"lesson_part": "main","type":"output"}
we get back the hash:

```{code-block} console
d670460b4b4aece5915caf5c68d12f560a9fe3e4
```

+++{"lesson_part": "main"}

Now let's run it again with a slight modification. `-w` option tells the command to also write that object to the database


```{code-cell} bash
:tags: ["skip-execution"]
echo "test content" | git hash-object -w --stdin
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
d670460b4b4aece5915caf5c68d12f560a9fe3e4
```
::::::{margin}
::::{important}
We all got the same hash because we all put the same content *into* the hashing algorithm (`test content`)
::::
:::::::

+++{"lesson_part": "main"}
and we can check if it wrote to the directory.
```{code-cell} bash
:tags: ["skip-execution"]
find .git/objects/ -type f
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
```
and we see a file that it was supposed to have!



+++{"lesson_part": "main","type":"heading"}
### Viewing git objects 


+++{"lesson_part": "main"}
We can try with `cat`
```{code-cell} bash
:tags: ["skip-execution"]
cat .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
xK??OR04f(I-.QH??+I?+?K?	
```


This is binary output that we cannot understand.  




+++{"lesson_part": "main"}
Fortunately, git provides a utility. We can use `cat-file` to use the object by referencing at least 4 characters that are unique from the full hash, not the file name. (`7046` will not work, but `d670` will)


`cat-file` requires *an* option `-p` is for pretty print

```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -p d670
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
test content
```
where we see the content we put in to the hashing function
+++{"lesson_part": "main"}
or `-t` for type: 

```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -t d670
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
blob
```


we see that it is a blob. 

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
ls
```
+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

::::{attention}
We have a {term}`git object <object>` but no files at this point
:::::


+++{"lesson_part": "main","type":"heading"}

### Hashing a file



+++{"lesson_part": "main"}
let's create a file, using a {term}`redirect`


```{code-cell} bash
:tags: ["skip-execution"]
echo "version 1" > test.txt
```



+++{"lesson_part": "main"}
and confirm it exists
```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
test.txt
```

+++{"lesson_part": "main"}
and its content

```{code-cell} bash
:tags: ["skip-execution"]
cat test.txt 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
version 1
```

+++{"lesson_part": "main"}
and store it,  by hashing it

```{code-cell} bash
:tags: ["skip-execution"]
git hash-object -w test.txt 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
83baae61804e65cc73a7201a7252750c76066a30
```

+++{"lesson_part": "main"}
we can look at what we have.
```{code-cell} bash
:tags: ["skip-execution"]
find .git/objects/ -type f
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
```
we see two objects as expected


+++{"lesson_part": "site"}

Now this is the status of our repo. 
```{mermaid}
classDiagram
    class d67046{
        + "test content"
        +(blob)
    }
    class 83baae{
       + Version 1
       + (blob)
    }
```


+++{"lesson_part": "main"}

We can check the type of files with `-t` and `git cat-file`
```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -t 83ba
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
blob
```
it is a blob object as expected

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -p 83ba
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
version 1
```

+++{"lesson_part": "main"}

Notice, however, that we only have one file in the working directory. 

```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	test.txt

nothing added to commit but untracked files present (use "git add" to track)
```


it is the one test.txt, the first blob we made had no file in the working directory associated to it. 


So far, even though we have hashed the object, git still thinks the file is untracked, because it is not in the tree and there are no commits that point to that part of the tree.



+++{"lesson_part": "site"}

:::::{attention}
the workign directory and the git repo are not strictly the same thing, and can be different like this.  Mostly they will stay in closer relationship that we currently have unless we use plumbling commands, but it is good to build a solid understanding of how the `.git` directory relates to your working directory.

::::::


+++{"lesson_part": "main","type":"heading"}


## Updating the Index

Now, we can add our file as it is to the index. 

the index is also called the staging area



+++{"lesson_part": "main"}

(updateindex)=
```{code-cell} bash
:tags: ["skip-execution"]
git update-index --add --cacheinfo 100644 \
 83baae61804e65cc73a7201a7252750c76066a30 test.txt
```

(updateindexinfo)=
- the `\` lets us wrap onto a second line.
- this the plumbing command `git update-index` updates (or in this case creates an index, the staging area of our repository)
- the `--add` option is because the file doesn’t yet exist in our staging area (we don’t even have a staging area set up yet)
- `--cacheinfo` because the file we're adding isn’t in your directory but is in the database.
- in this case, we’re specifying a mode of 100644, which means it’s a normal file.
- then the hash object we want to add to the index (the content) in our case, we want the hash of the first version of the file, not the most recent one.
- finally the file name of that content
+++{"lesson_part": "main","type":"output"}

```{code-block} console
```
this has no output

+++{"lesson_part": "main"}
Again, we check in with status
```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   test.txt

```


We have the files staged as expected


+++{"lesson_part": "main"}

Now the file is staged. 

Let's edit it further. 
```{code-cell} bash
:tags: ["skip-execution"]
echo "version 2" >> test.txt
```

+++{"lesson_part": "main"}
we can check the working directory again
```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
test.txt
```

+++{"lesson_part": "main"}
We can look at the content to ensure it as expected

```{code-cell} bash
:tags: ["skip-execution"]
cat test.txt 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
version 1
version 2
```
So the file has two lines


+++{"lesson_part": "main"}
Now check status again. 
```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   test.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   test.txt

```



We added the first version of the file to the staging area, so that version is ready to commit  but we have changed the version in our working directory relative to the version from the hash object that we put in the staging area so we *also* have changes not staged.



+++{"lesson_part": "main"}
We can hash and store this version too. 

```{code-cell} bash
:tags: ["skip-execution"]
git hash-object -w test.txt 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
0c1e7391ca4e59584f8b773ecdbbb9467eba1547
```

+++{"lesson_part": "main"}
We can then look again at our list of objects. 
```{code-cell} bash
:tags: ["skip-execution"]
find .git/objects/ -type f
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
.git/objects/0c/1e7391ca4e59584f8b773ecdbbb9467eba1547
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
```

+++{"lesson_part": "site"}

So now our repo has 3 items, all blobs
```{mermaid}
classDiagram
    class d67046{
        +"test content"
        +(blob)
    }
    class 83baae{
       +Version 1
       +(blob)
    }
    class 0c1e73{
        +Version 1
        +Verson 2
        +(blob)
    }
```

:::::{note}
The index is not represented by any {term}`git objects <object>`, it is a temporary space
::::::

+++{"lesson_part": "main"}

and again, check with git: 

```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   test.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   test.txt

```

hashing the object does not impact the index, which is what git status uses
+++{"lesson_part": "main","type":"heading"}


### Preparing to Commit

When we work with porcelain commands, we use add then commit.  We have staged the file, which we know is  what happens when we add.  What else has to happen to make a commit?  


We know that commits are comprised of:
- a message
- author and times stamp info
- a pointer to a tree
- a pointer to the parent (except the first commit)

We do not have any of these items yet, but we know that the message, author and time stamp come at the last bit when we make the commit.  

Let's make a tree next. 


+++{"lesson_part": "main"}
Now we can write a tree from the index,
```{code-cell} bash
:tags: ["skip-execution"]
git write-tree
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
```
and we get a hash
+++{"lesson_part": "main"}
Lets examine the tree, first check the type
```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -t d832
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
tree
```
it is as expected
+++{"lesson_part": "main"}
and now we can look at its contents
```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -p d832
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
100644 blob 83baae61804e65cc73a7201a7252750c76066a30	test.txt
```
it looks a lot like what we [put in the index](#updateindex)

+++{"lesson_part": "site"}


Now this is the status of our repo: 
```{mermaid}
classDiagram
    class d67046{
        +"test content"
        +(blob)
    }
    class 83baae{
       +Version 1
       +(blob)
    }
    class d8329f{
        +blob: 83baae
        +filename: test.txt
        +(tree)
    }
    class 0c1e73{
        +Version 1
        +Verson 2
        +(blob)
    }

    d8329f --|> 83baae
```

We have 3 blobs, and a tree that points to one of them

+++{"lesson_part": "main"}
Again, we will check in with git via `git status`
```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   test.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   test.txt

```
Nothing has changed, making the tree does not yet make the commit




+++{"lesson_part": "main","type":"heading"}


### Creating a commit manually

We can echo a commit message through a pipe into the commit-tree plumbing function to commit a particular hashed object.




+++{"lesson_part": "main"}

the `git commit-tree` command requires a message via  stdin and the tree hash.  We will use stdin and a pipe for the message

```{code-cell} bash
:tags: ["skip-execution"]
echo "first commit" | git commit-tree d832
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
da01135f2fb02e9b53c200708863df82f0daa50c
```


and we get back a hash. But notice that this hash is unique for each of us. Because the commit has information about the time stamp and our user.  



+++{"lesson_part": "main"}



The above hash is the one I got during class, but when I re-ran this while typing the notes last fall I got a different hash (`d450567fec96cbd8dd514313db9bcb96ad7664b0`) even though I have the same name and e-mail because the time changed.


+++{"lesson_part": "main"}
We can also look at its type
```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -t da01
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
commit
```

+++{"lesson_part": "main"}
and we can look at the content
```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -p da01
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Sarah M Brown <brownsarahm@uri.edu> 1759857348 -0400
committer Sarah M Brown <brownsarahm@uri.edu> 1759857348 -0400

first commit
```

+++{"lesson_part": "main"}


Now we check the final list of objects that we have for today

```{code-cell} bash
:tags: ["skip-execution"]
find .git/objects/ -type f
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
.git/objects/0c/1e7391ca4e59584f8b773ecdbbb9467eba1547
.git/objects/da/01135f2fb02e9b53c200708863df82f0daa50c
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
```



::::{important}
Check that you also hav 6 objects and 5 of them should match mine, the one you should not have is  `da01135` but you should have a different one. 
::::


+++{"lesson_part": "notes","type":"mermaid"}

Visually, this is what our repo looks like: 
```{mermaid}
classDiagram
    class d67046{
        +test content
        +(blob)
    }
    class 83baae{
        +Version 1
        +(blob)
    }
    class d8329f{
        +blob: 83baae
        +filename: test.txt
        +(tree)
    }
    class 0c1e73{
        +Version 1
        +Verson 2
        +(blob)
    }
    class da0113{
        +tree d8329f
        +author name
        +commiter time
    }
    d8329f --|> 83baae
    da0113 --|> d8329f
```



+++{"lesson_part": "main","type":"heading"}



## What does git status do? 

_compares the working directory to the current state of the active branch_


- we cansee the working directory with: `ls`
- we can see the active branch in the `HEAD` file 
- what is its status? 



+++{"lesson_part": "main"}

we have seen it is "on main" this is because we set the branch to main, but since we have not written there, we have to do it directly. 

Notice that when we use the porcelain command for commit, it does this automatically; the porcelain commands do many things.
```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   test.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   test.txt

```



Notice, git says we have no commits yet even though we have written a commit. 

In our case because we made the commit manually, we did not update the branch. 

 This is because the main branch does not *point* to any commit.




+++{"lesson_part": "main"}
We can verify by looking at the `HEAD` file

```{code-cell} bash
:tags: ["skip-execution"]
cat .git/HEAD 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
ref: refs/heads/main
```
as expected
+++{"lesson_part": "main"}
then we look at that file 
```{code-cell} bash
:tags: ["skip-execution"]
cat .git/refs/heads/main
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
cat: .git/refs/heads/main: No such file or directory
```

which does not even exist!



+++{"lesson_part": "main"}
we can see the objects though: 
```{code-cell} bash
:tags: ["skip-execution"]
find .git/objects/ -type f
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
.git/objects/0c/1e7391ca4e59584f8b773ecdbbb9467eba1547
.git/objects/da/01135f2fb02e9b53c200708863df82f0daa50c
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
```



+++{"lesson_part": "main","type":"heading"}

## Git References


+++{"lesson_part": "main"}

We can make that file manually

```{code-cell} bash
:tags: ["skip-execution"]
echo 0c1e7391ca4e59584f8b773ecdbbb9467eba1547 > .git/refs/heads/main
```
:::::{important}
here you need to use the *full* hash because we are writing a file directly that git will read, not using a git command. 

Also you need to use the hash of your commit
::::::

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

+++{"lesson_part": "main"}
then we check with git
```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
error: bad tree object HEAD
```

I made a typo, so it failed

+++{"lesson_part": "main"}

so I corrected it: 

```{code-cell} bash
:tags: ["skip-execution"]
echo da01135f2fb02e9b53c200708863df82f0daa50c > .git/refs/heads/main 
```

So we now have HEAD-> main and main -> our commit -> tree --> blob. 


+++{"lesson_part": "main"}
and git status works:

```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   test.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

+++{"lesson_part": "main"}
It still has the file with extra chagnes because we commited the first line only, not the second one. 

```{code-cell} bash
:tags: ["skip-execution"]
cat test.txt 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
version 1
version 2
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git diff 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
diff --git a/test.txt b/test.txt
index 83baae6..0c1e739 100644
--- a/test.txt
+++ b/test.txt
@@ -1 +1,2 @@
 version 1
+version 2
```

+++{"lesson_part": "main"}
## The git objects folder
```{code-cell} bash
:tags: ["skip-execution"]
ls .git/objects/
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
0c	83	d6	d8	da	info	pack
```

There was a question about why they are organized into folders. 

it looks like it is about speed of accessing partially, but more importantly because [folders can have a limit on the number of files in them](https://softwareengineering.stackexchange.com/questions/301400/why-is-the-git-git-objects-folder-subdivided-in-many-sha-prefix-folders)

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git log
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
commit da01135f2fb02e9b53c200708863df82f0daa50c (HEAD -> main)
Author: Sarah M Brown <brownsarahm@uri.edu>
Date:   Tue Oct 7 13:15:48 2025 -0400

    first commit
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -p da01
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Sarah M Brown <brownsarahm@uri.edu> 1759857348 -0400
committer Sarah M Brown <brownsarahm@uri.edu> 1759857348 -0400

first commit
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -p d832
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
100644 blob 83baae61804e65cc73a7201a7252750c76066a30	test.txt
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git cat-file -p 83baa
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
version 1
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]

```

+++{"lesson_part": "main","type":"output"}




## Prepare for Next Class 

```{include} ../_prepare/2025-10-09.md
```

## Badges

`````{tab-set}
````{tab-item} Review
```{include} ../_review/2025-10-07.md
```

````

````{tab-item} Practice
```{include} ../_practice/2025-10-07.md
```

````
`````



## Experience Report Evidence
## Experience Report Evidence


```{important}
You need to have a test repo that matches this for class on tuesday. 
```

Generate your evidence with the following in your test repo
```
find .git/objects/ -type f > testobj.md
```

then append the contents of your commit object to that file. 

Move the `testobj.md` to your kwl repo in the experiences folder. 


## Questions After Today's Class 

### What exactly happens inside .git/index—how is it structured to store file paths and hashes?

I have not been able to find a clear explanation of how the index stores the information, only how to put things in and get them out (into a tree). 

This is a good explore badge topic. 

### How does git know which tree or commit the HEAD is pointing to when multiple branches exist? 

It reads the `HEAD` file.  `git checkout` changes the `HEAD` file. 

### How do git write-tree and git commit-tree relate to git add` and git commit under the hood?

This is partially your badge for today, so great question! 

[the book section on the topic](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects) has a lot of information

### How will this content we learned be applied in future lessons in this class?

Next we will learn more advanced git porcelain commands and having a correct understanding of the internals helps make those make more sense. 


### Is there a ever a situation in which creating commits this way is more beneficial?

Probably not, it is an exercise in understanding what happens when you use the other commands so that you can understand if something goes wrong

### Can you have a bunch of trees linked to each ther that all hold their own blobs?

Yes. 

Thinking through how to create this (using porcelain or plumbing commands) is a good idea to practice with the concepts from today. 


### Is there a reason why the author and committer be different than what my email is?

You can set them, if you are using a computer where you have not used `git config` they can be different

### How can we display the contents of the index file in a human-readable way?

I have not found one, this is a good explore badge topic! 

### We may have covered this already, but what are the folders with hexadecimal names in .git/objects for?

They nake git more efficient, it is faster, and more flexible, some file systems can have limits on how many files can be in a folder. This drastically increases how many git objects can be stored on a computer with those limits. 

### if git stores commits as snapshots does that mean it saves several dupliate files for each commit?

Not quite, because since it hashes the file's content and then writes the content in a file names with the hash, if the file has not changed it overwrites the last snapshot's copy, with the same content. 

This is faster than even comparing because comparing two files is a complex operation, more than the hashing algorithm. 


### what are the main git objects that make up a commit?

A commit *is* a git {term}`object` but it has [several parts](#commit:defs:list)

### Is there ever a case where using the plumbing commands is necassary over the porcelain commands?

Not in normal use, but they need to be there for git to work, and we can use them to inspect and learn.  