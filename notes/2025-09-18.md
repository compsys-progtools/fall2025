---
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
--- 



# When do I get an advantage from the terminal? 

so far we have used git and bash to accomplish familiar goals, and git and bash feel like just extra work for familiar goals. 


We will do this by working in the `gh-inclass` repo on organizing a set of files.  This is still a familiar task, but we will show how doing on the terminal can make it faster[^learnfast], more robust to errors, and *automatable*[^llm]


[^learnfast]: After the initial adjustment period, *learning* new things can slow you down a bit, but once you get used to, the terminal makes things faster. 

[^llm]: with LLMs people now think that lots of things can be "automated" by delegating them to the "AI." However, LLMs *will* make mistakes, maybe not the first time, but they will make errors[^hallucinate]. Automating something with a script can *guarantee* it and make it happen, faster, cheaper[^llmcost], and more reliably, with a little bit of investment of your time up front. 

[^llmcost]: LLMs use extraordinary amounts of electricity and water @luccioni2024environmental, so using one for something that can be done with a script, over and over and over again is expensive (electricity costs $) and has a significant environmental impact. 

[^hallucinate]: AI errors are often called hallucinations. I try to avoid the term because hallucinations in a biological brain are perceptions of things that are not there-- a replacement of sensory information tha and are different than normal function. LLM hallucinations are provably inevitable @kalai2025language and are not technically different, it is a label we assign based on if the output is correct or not. 

+++{"lesson_part":"site"}

## Setting the stage

To [prepare for today's class](prep2024-09-19) you examined an open source project. 

We noticed that while the contents inside and the distribution of languages used as well 
as the specific code, or the *content* of the files was all different, a lot of the 
*organization* was similar. 

Most had certain [community health files](https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/creating-a-default-community-health-file) and basic info files:
- `CONTRIBUTING`
- `CODE_OF_CONDUCT`
- `README.MD`
- `LICENSE`
- `GOVERNANCE.MD`

+++{"lesson_part":"main"}

## Setup

First, we'll go back to our github inclass folder 

```{code-cell} bash
:tags: ["skip-execution"]
cd gh-inclass-brownsaram
```


+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
about.md	README.md
```

+++{"lesson_part": "main"}

and check in with git
```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch fun_fact
Your branch is up to date with 'origin/fun_fact'.

nothing to commit, working tree clean
```

+++{"lesson_part": "main"}
and then get updated

```{code-cell} bash
:tags: ["skip-execution"]
git pull
```

+++{"lesson_part": "site"}

::::::{margin}
::::{tip}
I have added line numbers to some output block so that I can highlight important lines
::::
::::::

+++{"lesson_part": "main","type":"output"}



```{code-block} console
:linenos:
:emphasize-lines: 7
remote: Enumerating objects: 18, done.
remote: Counting objects: 100% (18/18), done.
remote: Compressing objects: 100% (8/8), done.
remote: Total 18 (delta 0), reused 18 (delta 0), pack-reused 0 (from 0)
Unpacking objects: 100% (18/18), 1.64 KiB | 152.00 KiB/s, done.
From https://github.com/compsys-progtools/gh-inclass-fa25-brownsarahm
 * [new branch]      organizing_ac -> origin/organizing_ac
Already up to date.
```

:::::{attention}
Note there is a new branch, I created that to give you some files wo work with for today's class 
::::::


+++{"lesson_part": "main"}

Recall, we can use `git branch` with no inputs to see what branches we have locally

```{code-cell} bash
:tags: ["skip-execution"]
git branch
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
  1-add-a-readme
  fun_fact
* main
  my_branch
```

the new branch does not show, becuase while it has been pulled and git can tell what it should be, we have not *used* it locally so it does not really exist yet locally. 

+++{"lesson_part": "main"}

To see branches that are in the {term}`remote` we use the `-r` flag. 
```{code-cell} bash
:tags: ["skip-execution"]
git branch -r
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
:linenos:
:emphasize-lines: 5
  origin/1-add-a-readme
  origin/HEAD -> origin/main
  origin/fun_fact
  origin/main
  origin/organizing_ac
```

Now we have the new branch! 

+++{"lesson_part": "main"}

We can switch to it with `checkout`

```{code-cell} bash
:tags: ["skip-execution"]
git checkout organizing_ac
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
branch 'organizing_ac' set up to track 'origin/organizing_ac'.
Switched to a new branch 'organizing_ac'
```

+++{"lesson_part": "main"}

Now, if we look at the contents of the working direcotry again, to see what the new branch includes. 
```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
_config.yml		LICENSE.md
_toc.yml		philosophy.md
abstract_base_class.py	README.md
alternative_classes.py	scratch.ipynb
API.md			setup.py
CONTRIBUTING.md		tests_alt.py
example.md		tests_helpers.py
helper_functions.py	tests_imp.py
important_classes.py	tsets_abc.py
```

+++{"lesson_part": "site"}
::::::{attention}
We have a lot of new files that were not in the working directory before! `git checkout` does two things: 
1. move the `HEAD` pointer to the new branch (here, `organizing_ac`) 
2. set the contents to the working directory to the contents in the repository as of the last commit on that branch (where the branch pointer points)
:::::::




+++{"lesson_part":"main"}

## Organizing a project (working with files)

A common question is about how to organize projects.  While our main focus
in this class session is the `bash` commands to do it, the _task_ that we are
going to do is to organize a hypothetical python project


Put another way, we are using organizing a project as the *context* to motivate practicing with
bash commands for moving files. 


A different the instructor might go through a slide deck that lists commands and describes what each one does and then have examples at the end.  Instead, we are going to focus on organizing files, and I will introduce the commands we need along the ways. 



+++{"lesson_part":"main"}

next we are going to pretend we worked on the project and made a bunch of files 

I gave a bunch of files, each with a short phrase in them. 

- none of these are functional files
- the phrases mean you can inspect them on the terminal

+++{"lesson_part":"site"}

(extensionspeople)=
::::{important}
file extensions are for people; they do not specify what the file is actually written like
:::::


+++{"lesson_part":"main"}

these are all *actually* plain text files


+++{"lesson_part":"main"}



`cat` concatenates the contents of a file to {term}`STDOUT`, which can be thought of like a special file that our terminal reads 

+++{"lesson_part":"site"}

::::{admonition} ðŸ”— You may have interacted with this file before
:icon: false
think about in C you can write to STDOUT or STDERR, some IDEs have separate visual panels for these two places
:::::


so for example: 

```{code-cell} bash
:tags: ["skip-execution"]
cat API.md 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
jupyterbook file to generate api documentation 
```

+++{"lesson_part": "main"}
 or: 
```{code-cell} bash
:tags: ["skip-execution"]
cat scratch.ipynb 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
jupyter notebook from dev
```

+++{"lesson_part": "main"}


we will create a new branch before we start doing some new work. We do not have to have this branch off of main, it can be off of the one we are already on.  Remember branches are not copies they are pointers to different specific commits. 

```{code-cell} bash
:tags: ["skip-execution"]
git  checkout -b organization
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Switched to a new branch 'organization'
```

+++{"lesson_part": "main"}
and confirm it is as we expect. 
```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch organization
nothing to commit, working tree clean
```


## Manipulating the Streams

The {term}`STDOUT` {term}`stream` can be manipulated.  Any time we open or manipulate a file, it goes through a stream. So we can use other files in place of how we by default use STDOUT. 

+++{"lesson_part": "main"}

To try this out, let's first recall what is in the README file. 
```{code-cell} bash
:tags: ["skip-execution"]
cat README.md 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
# GitHub practice

test
```

+++{"lesson_part": "main"}

`echo` is a simple command that repeats what you have done, again by default to STDOUT. 

```{code-cell} bash
:tags: ["skip-execution"]
echo "hello"
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
hello
```
not so exciting, but there is a way we can use this! 

+++{"lesson_part":"site"}

:::::{attention}
An important part of the unix philosophy (that underlies bash and lots of other design in computing today) is to make small programs that each do one thing well and then connect them together to accomplish more complex tasks. 

:::::::


+++{"lesson_part":"site"}
:::::{admonition} ðŸ”—
:icon: false

Typically, when we write to a file, in programming,  we also have to tell it what *mode* to open the file with, and some options are: 
- read
- write
- append

This could be familiar from:
- `fopen` in C
- or `open` in Python

References

- [C language docs from IBM](https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-fopen-open-file)
- [Python official docs](https://docs.python.org/3/library/functions.html#open)


*C is not an open source language in the typical sense so there is no "official" C docs*
::::::::

+++{"lesson_part":"main"}

We can also redirect (send) the contents of a command from stdout to a file in `bash`. Like file operations while programming there is a similar concept to this mode. 

There are two types of redirects, like there are two ways to write to a file, more generally: 
- overwrite (`>`)
- append (`>>`)


These sybols are each called a {term}`redirect` 

+++{"lesson_part": "main"}
### Redirect in append mode

We can use a  to send output of any command to a different {term}`stream` than STDOUT. So for example, we can send a phrase into the `README.md` file. 

```{code-cell} bash
:tags: ["skip-execution"]
echo "today is rainy" >> README.md 
```

+++{"lesson_part": "main","type":"output"}

This time there was no output, since nothing when to STDOUT. 
```{code-block} console
```

+++{"lesson_part": "main"}
Then we check the contents of the file and we see that the new content is there. 
```{code-cell} bash
:tags: ["skip-execution"]
cat README.md 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
:linenos:
:emphasize-lines: 4
# GitHub practice

test
today is rainy
```
the new content! 

+++{"lesson_part": "main"}

### Redirect in write mode

We can redirect other commands too. This time we will use one `>` to use write mode instead of append mode.  

```{code-cell} bash
:tags: ["skip-execution"]
git status > curgit
```

+++{"lesson_part": "main","type":"output"}
Again no output
```{code-block} console
```

+++{"lesson_part": "main"}
The `curgit`[^noext] file did not exist before, so let's see if it is there.

[^noext]: notice that there is no extension! [can you remember why?](#extensionspeople)

```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
_config.yml		LICENSE.md
_toc.yml		philosophy.md
abstract_base_class.py	README.md
alternative_classes.py	scratch.ipynb
API.md			setup.py
CONTRIBUTING.md		tests_alt.py
curgit			tests_helpers.py
example.md		tests_imp.py
helper_functions.py	tsets_abc.py
important_classes.py
```
it's there

+++{"lesson_part": "main"}

and we can look at its contents too

```{code-cell} bash
:tags: ["skip-execution"]
cat curgit 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch organization
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   README.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	curgit

no changes added to commit (use "git add" and/or "git commit -a")
```

+++{"lesson_part": "main"}
(rightresolve)=
### Connected bash commands work right to left

From the contents of the file, we can see something really important about how the redirect (and other ways of chaining `bash` commands together) work. 

Notice that above, the `curgit` file is mentioned in the `git status` that is in the contents of the `curgit` file.  We didn't create the file on purpose before we ran the line `git status > curgit`.  This is because `bash` works partially right to left and then resolves after. So, what happens is:
1. the file `curgit` is created and a stream to it is opened
1. the STDOUT stream is connected to that stream
1. `git status` runs, it compares the working directory to the last commit, sends its output to STDOUT which is connected to `curgit` 
1. the file stream is closed. 



+++{"lesson_part": "main"}
this is not a file we actually want, which gives us a chance to learn another new bash command: 
`rm` for remove, *removes* the entry for this file from the file table. Your computer keeps track of all of the paths and where in the disk (like the memory address) the corresponding content is.  if we have no entry, we cannot, using normal tools, find the contents, though it is not  erased from the disk or overwritten. The OS is then free to overwrite those bits if needed.  

```{code-cell} bash
:tags: ["skip-execution"]
rm curgit 
```

+++{"lesson_part":"site"}

:::::{important}
This is a true, full, and complete DELETE, this does not put the file in your recycling bin or the apple trash can that you can recover the file from, it is **gone** for real. 

We will see soon a way around this, because git can help. 

*use `rm` with great care*
:::::::


+++{"lesson_part": "main"}
Let's check in with git

```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch organization
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
```

+++{"lesson_part": "main"}
Now we have made some changes we want, so let's commit our changes.  
```{code-cell} bash
:tags: ["skip-execution"]
git commit -a -m 'add note to readme'
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
[organization 285dd21] add note to readme
 1 file changed, 1 insertion(+)
```

+++{"lesson_part": "main"}

and confirm a clean working directory

```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch organization
nothing to commit, working tree clean
```

+++{"lesson_part": "main"}
## Git can save you from mistakes

Let's try another redirect. With two we append to the file, with one, in write mode for a file with pre-exisiting content, let's see: 

```{code-cell} bash
:tags: ["skip-execution"]
echo "rain is sad" > README.md 
```



+++{"lesson_part": "main"}
andd then check the file
```{code-cell} bash
:tags: ["skip-execution"]
cat README.md 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
rain is sad
```


+++{"lesson_part":"main"}


It wrote over the old content with this new content.  This would be bad, we lost content, but this is what git is for! 

It is *very very* easy to undo work since our last commit.  

This is good for times when you have something you have an idea and you do not know if it is going to work, so you make a commit before you try it. Then you can try it out.  If it doesn't work you can undo and go back to the place where you made the commit. 

+++{"lesson_part": "main"}


To do this, we will first check in with git


```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
:linenos:
:emphasize-lines: 4
On branch organization
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
```

+++{"lesson_part":"main"}


Notice that it tells us what to do `(use "git restore <file>..." to discard changes in working directory)`.  The version of README.md that we broke is in the working directory but not commited to git, so git refers to them as "changes" in the working directory. 

+++{"lesson_part": "main"}
We run that command
```{code-cell} bash
:tags: ["skip-execution"]
git restore README.md 
```


+++{"lesson_part":"main"}

this command has no output, so we can use git status to check first

+++{"lesson_part": "main"}
and we can check the file
```{code-cell} bash
:tags: ["skip-execution"]
cat README.md 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
# GitHub practice

test
today is rainy
```

+++{"lesson_part":"main"}

Back how we wanted it! 

+++{"lesson_part": "main"}

## Manipulating files with bash

Next we will add some descriptive content to the README

```{code-cell} bash
:tags: ["skip-execution"]
 echo "|file | contents |
> > | --| -- |
> > | abstract_base_class.py | core abstract classes for the project |
> > | helper_functions.py | utitly funtions that are called by many classes |
> > | important_classes.py | classes that inherit from the abc |
> > | alternative_classes.py | classes that inherit from the abc |
> > | LICENSE.md | the info on how the code can be reused|
> > | CONTRIBUTING.md | instructions for how people can contribute to the project|
> > | setup.py | file with function with instructions for pip |
> > | test_abc.py | tests for constructors and methods in abstract_base_class.py|
> > | tests_helpers.py | tests for constructors and methods in helper_functions.py|
> > | tests_imp.py | tests for constructors and methods in important_classes.py|
> > | tests_alt.py | tests for constructors and methods in alternative_classes.py|
> > | API.md | jupyterbook file to generate api documentation |
> > | _config.yml | jupyterbook config for documentation |
> > | _toc.yml | jupyter book toc file for documentation |
> > | philosophy.md | overview of how the code is organized for docs |
> > | example.md | myst notebook example of using the code |
> > | scratch.ipynb | jupyter notebook from dev |" >> README.md
```


+++{"lesson_part":"main"}

this explains each file a little bit more than the name of it does.
We see there are sort of 5 groups of files:
- about the project/repository
- code that defines a python module
- test code
- documentation
- extra files that "we know" we can delete.

We also learn something about bash: 
using the open quote `"` then you stay inside that until you close it. when you press enter the command does not run until after you close the quotes


+++{"lesson_part": "main"}
let's look at the file again

```{code-cell} bash
:tags: ["skip-execution"]
cat README.md 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
# GitHub practice

test
today is rainy
|file | contents |
> | --| -- |
> | abstract_base_class.py | core abstract classes for the project |
> | helper_functions.py | utitly funtions that are called by many classes |
> | important_classes.py | classes that inherit from the abc |
> | alternative_classes.py | classes that inherit from the abc |
> | LICENSE.md | the info on how the code can be reused|
> | CONTRIBUTING.md | instructions for how people can contribute to the project|
> | setup.py | file with function with instructions for pip |
> | test_abc.py | tests for constructors and methods in abstract_base_class.py|
> | tests_helpers.py | tests for constructors and methods in helper_functions.py|
> | tests_imp.py | tests for constructors and methods in important_classes.py|
> | tests_alt.py | tests for constructors and methods in alternative_classes.py|
> | API.md | jupyterbook file to generate api documentation |
> | _config.yml | jupyterbook config for documentation |
> | _toc.yml | jupyter book toc file for documentation |
> | philosophy.md | overview of how the code is organized for docs |
> | example.md | myst notebook example of using the code |
> | scratch.ipynb | jupyter notebook from dev |
```

+++{"lesson_part": "main"}

First, we'll make a directory with `mkdir`

```{code-cell} bash
:tags: ["skip-execution"]
mkdir docs
```


+++{"lesson_part": "main"}
next we will move a file there with `mv`

```{code-cell} bash
:tags: ["skip-execution"]
mv philosophy.md  docs/
```

+++{"lesson_part":"main"}


what this does is change the path of the file from `gh-inclass-fa25-brownsarahm/philosophy.md` to `gh-inclass-fa25-brownsarahm/docs/philosophy.md`

It does not rewrite the file contents to disk, so even for large files this is quick, it changes only the file table that stores each path and a disk address. 


+++{"lesson_part": "main"}
we can look  in the docs folder
```{code-cell} bash
:tags: ["skip-execution"]
cd docs/
```


+++{"lesson_part": "main"}
and use ls
```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
philosophy.md
```


+++{"lesson_part": "main"}
or go back 
```{code-cell} bash
:tags: ["skip-execution"]
cd ..
```



+++{"lesson_part": "main"}
and use `ls` with the {term}`relative path` to where we moved it

```{code-cell} bash
:tags: ["skip-execution"]
ls docs/
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
philosophy.md
```

+++{"lesson_part": "main"}
we can also check the original location

```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
_config.yml		important_classes.py
_toc.yml		LICENSE.md
abstract_base_class.py	README.md
alternative_classes.py	scratch.ipynb
API.md			setup.py
CONTRIBUTING.md		tests_alt.py
docs			tests_helpers.py
example.md		tests_imp.py
helper_functions.py	tsets_abc.py
```
not there! 


+++{"lesson_part":"main"}




### Moving multiple files with patterns

+++{"lesson_part":"main"}


We can use the `*` [wildcard operator](https://tldp.org/LDP/GNU-Linux-Tools-Summary/html/x11655.htm) to move all files that match the pattern. We'll start with the two `yml` [(yaml)](https://yaml.org/)
files that are both for the documentation.

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
mv *.yml docs/
```


+++{"lesson_part": "main"}
Again, we confirm it worked by seeing that they are no longer in the working directory.
```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
abstract_base_class.py	LICENSE.md
alternative_classes.py	README.md
API.md			scratch.ipynb
CONTRIBUTING.md		setup.py
docs			tests_alt.py
example.md		tests_helpers.py
helper_functions.py	tests_imp.py
important_classes.py	tsets_abc.py
```

+++{"lesson_part": "main"}
and that they *are* in `docs`
```{code-cell} bash
:tags: ["skip-execution"]
ls docs/
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
_config.yml	_toc.yml	philosophy.md
```



+++{"lesson_part":"main"}


We see that most of the test files start with `tests_` but one starts with
`tsets_`. We can fix this!


+++{"lesson_part":"main"}

### Renaming files

We can use `mv` to change the name as well. This is because "moving" a file and
is really about changing its path, not actually copying it from one location to
another and the file name is a part of the path.

```{code-cell} bash
:tags: ["skip-execution"]
mv tsets_abc.py tests_abc.py
```

+++{"lesson_part":"main"}

This changes the path from `.../tsets_abc.py` to `.../tests_abc.py` to. It is doing the *same thing* as when we use it to move a file from one folder to another folder,  but changing a different part of the path. 



+++{"lesson_part": "main"}
we can use `ls` to check that it worked
```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
abstract_base_class.py	LICENSE.md
alternative_classes.py	README.md
API.md			scratch.ipynb
CONTRIBUTING.md		setup.py
docs			tests_abc.py
example.md		tests_alt.py
helper_functions.py	tests_helpers.py
important_classes.py	tests_imp.py
```

+++{"lesson_part": "main"}
Now we make a new folder: 
```{code-cell} bash
:tags: ["skip-execution"]
mkdir tests
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

+++{"lesson_part": "main"}
and move all of the test files there:
```{code-cell} bash
:tags: ["skip-execution"]
mv tests_* tests/
```

+++{"lesson_part":"site"}

::::{attention}
this is why good file naming is important even if you have not organized the
whole project yet, you can use the good conventions to help yourself later.
::::


+++{"lesson_part":"main"}

## Hidden files 

We saw before that some files and folders are [hidden](#hiddenfirst)

+++{"lesson_part": "main"}

and that to see them with `ls` we need the `-a` {term}`flag`
```{code-cell} bash
:tags: ["skip-execution"]
ls -a
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
.			example.md
..			helper_functions.py
.git			important_classes.py
.github			LICENSE.md
abstract_base_class.py	README.md
alternative_classes.py	scratch.ipynb
API.md			setup.py
CONTRIBUTING.md		tests
docs
```

+++{"lesson_part": "main"}
We are going to make a special hidden file and an extra one. We will use the following command: 

```{code-cell} bash
:tags: ["skip-execution"]
touch .secret .gitignore
```

+++{"lesson_part":"main"}

We also learn 2 things about `touch` and `bash`:
- `touch` can make multiple files at a time
- lists in `bash` are separated by spaces and do not require brackets



+++{"lesson_part": "main"}
lets put some content in the secret file, this is simple text, but it represents a real type of content, things we need but do not want to share with collaborators or make public. 

```{code-cell} bash
:tags: ["skip-execution"]
echo "my dev secret" > .secret 
```

+++{"lesson_part":"site"}

::::::::{important}
It is common in project to have an API key or secret that you need to keep with your code for it to run, but that you do not want to share. 

Not everyone is careful with them though, [over 12k were found in LLM training sets](https://thehackernews.com/2025/02/12000-api-keys-and-passwords-found-in.html)
:::::::::::


+++{"lesson_part": "main"}
again, we still do not see the file, it's {term}`hidden <hidden file>` from a casual user already!

```{code-cell} bash
:tags: ["skip-execution"]
ls
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
abstract_base_class.py	important_classes.py
alternative_classes.py	LICENSE.md
API.md			README.md
CONTRIBUTING.md		scratch.ipynb
docs			setup.py
example.md		tests
helper_functions.py
```


+++{"lesson_part": "main"}
but we can see them both
```{code-cell} bash
:tags: ["skip-execution"]
ls -a
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
.			docs
..			example.md
.git			helper_functions.py
.github			important_classes.py
.gitignore		LICENSE.md
.secret			README.md
abstract_base_class.py	scratch.ipynb
alternative_classes.py	setup.py
API.md			tests
CONTRIBUTING.md
```

+++{"lesson_part": "main"}

and the file is normally visible to all bash commands

```{code-cell} bash
:tags: ["skip-execution"]
cat .secret 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
my dev secret
```

+++{"lesson_part": "main"}

Let's check in with git 
```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
:linenos:
:emphasize-lines: 17
On branch organization
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   README.md
	deleted:    _config.yml
	deleted:    _toc.yml
	deleted:    philosophy.md
	deleted:    tests_alt.py
	deleted:    tests_helpers.py
	deleted:    tests_imp.py
	deleted:    tsets_abc.py

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	.gitignore
	.secret
	docs/
	tests/

no changes added to commit (use "git add" and/or "git commit -a")
```

git sees the file but it is not yet tracked. If we were to use `git add .` it would start getting tracked. We do not want that and we do not want to have to manually add each other file and just avoid this one. 

+++{"lesson_part":"main"}

gitignore lets us *not* track certain files

let's ignore that `.secret` file 

```{code-cell} bash
:tags: ["skip-execution"]
echo ".secret" >>.gitignore
```


+++{"lesson_part": "main"}
Now we check with git again: 
```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch organization
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   README.md
	deleted:    _config.yml
	deleted:    _toc.yml
	deleted:    philosophy.md
	deleted:    tests_alt.py
	deleted:    tests_helpers.py
	deleted:    tests_imp.py
	deleted:    tsets_abc.py

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	.gitignore
	docs/
	tests/

no changes added to commit (use "git add" and/or "git commit -a")
```

no more secret! 

+++{"lesson_part": "main"}
the file is still there: 
```{code-cell} bash
:tags: ["skip-execution"]
cat .secret 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
my dev secret
```

+++{"lesson_part": "main"}
## Tracking moved files 

Now we want to add the rest of the files we did, notice that above in the `git status` it thought we had deleted a lot of files that we had actually moved. 

Let's add one of the folders for tracking
```{code-cell} bash
:tags: ["skip-execution"]
git add docs/
```


+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch organization
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	new file:   docs/_config.yml
	new file:   docs/_toc.yml
	new file:   docs/philosophy.md

Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   README.md
	deleted:    _config.yml
	deleted:    _toc.yml
	deleted:    philosophy.md
	deleted:    tests_alt.py
	deleted:    tests_helpers.py
	deleted:    tests_imp.py
	deleted:    tsets_abc.py

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	.gitignore
	tests/

```

it still thinks the files are deleted, but also that there are new files. 

+++{"lesson_part": "main"}

Now let's add all 

```{code-cell} bash
:tags: ["skip-execution"]
git add .
```


+++{"lesson_part": "main"}
and status
```{code-cell} bash
:tags: ["skip-execution"]
git status
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
On branch organization
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	new file:   .gitignore
	modified:   README.md
	renamed:    _config.yml -> docs/_config.yml
	renamed:    _toc.yml -> docs/_toc.yml
	renamed:    philosophy.md -> docs/philosophy.md
	renamed:    tsets_abc.py -> tests/tests_abc.py
	renamed:    tests_alt.py -> tests/tests_alt.py
	renamed:    tests_helpers.py -> tests/tests_helpers.py
	renamed:    tests_imp.py -> tests/tests_imp.py

```

Now, it knows that we have actually *renamed* the files. 

We had to tell it to track the changes to both `.` and `docs` for it to detect that they were the same files that we had only moved. It compares files using their names but also the *contents*.  We will pick up from this idea more next week, but this is an important observation. 

+++{"lesson_part": "main"}

Finally, we will commit
```{code-cell} bash
:tags: ["skip-execution"]
git commit -m 'begin reorg
> '
```
::::{tip}
I forgot to close my `'` for the message so it gave me a continued prompt with `>` at the start and then i had to close it and press <kbd>enter</kbd> or <kbd>return</kbd> a second time
:::::

+++{"lesson_part": "main","type":"output"}

```{code-block} console

[organization e899a0e] begin reorg
 9 files changed, 20 insertions(+)
 create mode 100644 .gitignore
 rename _config.yml => docs/_config.yml (100%)
 rename _toc.yml => docs/_toc.yml (100%)
 rename philosophy.md => docs/philosophy.md (100%)
 rename tsets_abc.py => tests/tests_abc.py (100%)
 rename tests_alt.py => tests/tests_alt.py (100%)
 rename tests_helpers.py => tests/tests_helpers.py (100%)
 rename tests_imp.py => tests/tests_imp.py (100%)
```





## Recap

Why do I need a terminal
1. replication/automation
1. it's always there and doesn't change  
1. it's faster one you know it (also see above)



## Prepare for Next Class 

```{include} ../_prepare/2025-09-23.md
```

## Badges

`````{tab-set}
````{tab-item} Review
```{include} ../_review/2025-09-18.md
```

````

````{tab-item} Practice
```{include} ../_practice/2025-09-18.md
```

````
`````



## Experience Report Evidence

::::::::{important}
The prepare work for both Tuesday and today had a file in it so you need to make sure that those get added to your experience badges. Review the [process](#badges:procedure:experience)
::::::::::::::


Save your history with: 
```
history > activity-2025-09-18.md
```

then append your git status, and the contents of your github-in-class and github-in-class/docs with  to help visually separate the parts. 

```bash
echo "***--" >> activity-2025-09-18.md
git status >> activity-2025-09-18.md
echo "***--" >> activity-2025-09-18.md
ls >> activity-2025-09-18.md
echo "***--" >> activity-2025-09-18.md
ls docs/ >> activity-2025-09-18.md
```
then edit that file (on terminal, any text editor, or an IDE) to make sure it only includes things from this activity. 

## Questions After Today's Class 



### How much longer is the grace period for badges?

````{code-cell} python
:tags: [remove-cell]
from cspt import EARLY_BIRD_DEADLINE_STR
````
The [penalty free zone](#grading:penaltyfree) ends on {eval}`EARLY_BIRD_DEADLINE_STR`


### I'm interested in learning more about wildcard operators.

They are an example of a type of o pattern matching. The most general is regular expressions.  This is a good [explore](#badges:procedure:explore) badge topic. 

### Do patterns and the wild card operator (*) apply to all terminal commands?

I am sure some exist that do not, especially since people can make their own, but most `bash` commands that take a file as input do accept this. 