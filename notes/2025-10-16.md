---
file_format: mystnb
kernelspec:
    name: python3
---

# How can I automate things with bash?
+++{"lesson_part": "main"}

So far we have used bash commands to navigate our file system as a way to learn about the file system itself. To do this we used commands like:
- `mv`
- `cd`
- `pwd`
- `ls` 
- `find`
- `rm`

+++{"lesson_part": "site"}

::::{exercise}
:label: bashrev
Explain what each of those does. 

:::::


:::::{solution} bashrev
:class: dropdown
:::{embed} bashcommands
:::
::::::::



+++{"lesson_part": "site","type":"drawing"}

```{mermaid}
flowchart TD
    shell --> |is accessed through| terminal
    bash --> |is instance of| shell
    zsh --> |is instance of| shell
    git --> |is a program accessed though | shell

```

+++{"lesson_part": "main"}

Bash is a unix shell for the GNU operating system and it has been adopted in other contexts as well.  It is the default shell on Ubuntu linux as well for example (and many others). This is why we teach it. 


+++{"lesson_part": "main"}
A Unix shell is both a command interpreter and a programming language. As a command interpreter, the shell provides the user interface to the rich set of GNU utilities. The programming language features allow these utilities to be combined. 


Read the official definition of `bash` and a shell in [the bash manual](https://www.gnu.org/software/bash/manual/bash.html#Introduction)


+++{"lesson_part": "site"}

```{mermaid}
flowchart TD
    subgraph shell
        pl[programming language]
        i[command interpreter]
    end

```

+++{"lesson_part": "main","type":"heading"}


## Inspecting an example script


+++{"lesson_part": "main"}

Today we will start by inspecting the github action file, first we'll navigate to the folder. 


+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
cd fall25-kwl-brownsarahm/
```



+++{"lesson_part": "main"}
We want to look at a file if we get this far and then press <kbd>tab</kbd> mulitple times, it will show us the options
```{code-cell} bash
:tags: ["skip-execution"]
cat .github/workflows/
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
create_about.yml         forgottenexperience.yml  logger.yml
experienceinclass.yml    getassignment.yml        
experiencereport.yml     label_badges.yml         
```

+++{"lesson_part": "main"}

Then we will look at the getassignmet one.
```{code-cell} bash
:tags: ["skip-execution"]
cat .github/workflows/getassignment.yml 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
name: Create badge issues (Do not run manually)
on:
  workflow_dispatch

# once you edit, change the name

jobs:
  check-contents:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v5
    
    # Install dependencies
    - name: Set up Python 
      uses: actions/setup-python@v5
      with:
        python-version: 3.12
    
    - name: Install Utils
      run: |
        pip install git+https://github.com/compsys-progtools/courseutils@main
    - name: Get badge requirements
      run: |
        # prepare badge lines
        pretitle="prepare-"$(cspt getbadgedate --prepare)
        cspt getassignment --type prepare | gh issue create --title $pretitle --label prepare --body-file -
        # review badge lines
        rtitle="review-"$(cspt getbadgedate --review)
        cspt getassignment --type review | gh issue create --title $rtitle --label review --body-file -
        # practice badge lines
        pratitle="practice-"$(cspt getbadgedate --practice)
        cspt getassignment --type practice | gh issue create --title $pratitle --label practice --body-file -
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#  edit the run step above for the level(s) you want. 
#  You should keep the prepare, because they are required for experience badges 
#     You may choose to get only the review or only the practice (and change this any time) 
```

:::::{attention}
We reviewed a lot of the syntax here.  

For a community badge insert an explanation for one or more part via PR
::::::

+++{"lesson_part": "main"}
::::{important}
Edit this file to uncomment the lines about schedule and add a `:` after `workflow dispatch`
:::::
```{code-cell} bash
:tags: ["skip-execution"]
nano .github/workflows/label_badges.yml 
```



+++{"lesson_part": "main"}
then commit directly to main
```{code-cell} bash
:tags: ["skip-execution"]
git add .
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git commit -m 'turn on schedule'
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
[main 3f55616] turn on schedule
 1 file changed, 2 insertions(+), 2 deletions(-)
```

+++{"lesson_part": "main"}
and push
```{code-cell} bash
:tags: ["skip-execution"]
git push
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Enumerating objects: 9, done.
Counting objects: 100% (9/9), done.
Delta compression using up to 16 threads
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 460 bytes | 460.00 KiB/s, done.
Total 5 (delta 3), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
To https://github.com/compsys-progtools/fall25-kwl-brownsarahm.git
   4714a02..3f55616  main -> main
```

+++{"lesson_part": "main","type":"heading"}


## Variables in Bash



+++{"lesson_part": "main"}
The basic syntas is:

```{code-cell} bash
:tags: ["skip-execution"]
MYVAR=my_val
```

where:
- `MYVAR` is the variable name
- `my_val` is the value assigned to the variable



+++{"lesson_part": "main","type":"output"}

```{code-block} console
```

+++{"lesson_part": "main"}
so for example: 

```{code-cell} bash
:tags: ["skip-execution"]
NAME='sarah'
```

+++{"lesson_part": "site"}

::::{important}
notice that there are **no spaces** around the `=`. spaces in bash separate commands and options, so they cannot be in variable declarations.  
:::::

+++{"lesson_part": "main"}

A common mistake is to put a space around the `=` sign, this is actually considered **good style** in many other languages. 

```{code-cell} bash
:tags: ["skip-execution"]
NAME = 'sarah'
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
-bash: NAME: command not found
```

In bash, however, this creates an error.  When there is a space after `NAME`, `bash` tried to interpet `NAME` as a bash command, but then it does not find it, so it gives an error. 
+++{"lesson_part": "main"}
Removing the space works again: 
```{code-cell} bash
:tags: ["skip-execution"]
NAME='sarah'
```



+++{"lesson_part": "main"}
we can use variables with a `$` before the variable name. 
```{code-cell} bash
:tags: ["skip-execution"]
echo $NAME
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
sarah
```

+++{"lesson_part": "main"}
## Environment Variables

Environment variables are global. 

+++{"lesson_part": "main"}

A common one is the `PATH`. This variable is where your computer looks for programs to run when you call commands. 
+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
echo $PATH
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
/Users/brownsarahm/miniforge3/condabin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Frameworks/Python.framework/Versions/3.13/bin
```

+++{"lesson_part": "main"}
Another is `PS1`, this sets your prompt
```{code-cell} bash
:tags: ["skip-execution"]
echo $PS1
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
\u@\W \$
```

This one sets my prompt to look like:
`username@last_part_of_path $`

so if my path is `/Users/brownsarahm/Documents/inclass` my prompt will read `brownsarahm@inclass $` 

:::::{seealso}
[you can use a tool to set up a prompt](/Users/brownsarahm/Documents/)
::::::

+++{"lesson_part": "main"}

You can store environment variables to be set each time you start a terminal 
in your profile. 

- On MacOS this file is: `~/.bash_profile`
- on linux it is `~/.baschrc`

::::::{admonition} âš“ Find what works on GitBash
submit it to replace this block via a PR for a community badge
:::::::::

+++{"lesson_part": "main"}
## Variables are path independent
We can, however use the variable at different working directories. So if we move
```{code-cell} bash
:tags: ["skip-execution"]
cd ../gh-inclass-fa25-brownsarahm/
```



+++{"lesson_part": "main"}
and call it again
```{code-cell} bash
:tags: ["skip-execution"]
echo $NAME
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
sarah
```

still works ! 
:::::{important}

This variable is local, in memory, to the current terminal window, so if we open a separate window and try `echo $NAME` it will not work. We can also see that it does not create any file changes. 

:::::

+++{"lesson_part": "main"}

The `$` is essential syntax for recalling variables in bash. If we forget it, it treats it as a literal

```{code-cell} bash
:tags: ["skip-execution"]
echo NAME
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
NAME
```
so we get the variable **name** out instead of the variable **value**



+++{"lesson_part": "main","type":"heading"}




## GH Actions as an example of scripts



Check out the [github action marketplace](https://github.com/marketplace?type=actions) to see other actions that are available and try to get a casual level of understanding of the *types* of things that people use actions for. 

+++{"lesson_part": "main","type":"heading"}




## Bash Loops

We can also make loops like

```
for loopvar in list
do
# loop body
echo $loopvar
done
```

+++{"lesson_part": "main"}

So, for example: 

```{code-cell} bash
:tags: ["skip-execution"]
for name in Sarah Karter Kevin
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
> do
> echo $name
> done
Sarah
Karter
Kevin
```

Notes:

- The `>` is not typed, it is what happens since the interpreter knows that
after we write the first line, the command is not complete.
- a list in bash is items with spaces, no brackets here 

+++{"lesson_part": "main"}


When we get the command back with the up arrow key, it puts it all on one line, because it was one command.  The `;` (semicolon) separates the "lines"

```{code-cell} bash
:tags: ["skip-execution"]
for name in Sarah Karter Kevin Jack Ayman; do echo $name; done
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Sarah
Karter
Kevin
Jack
Ayman
```


+++{"lesson_part": "main","type":"heading"}



## Nesting commands


+++{"lesson_part": "main"}
We can run a command to generate the list by putting it inside `$()` to run that command first.  Think kind of like PEMDAS and the `$` in bash is for variables. 


```{code-cell} bash
:tags: ["skip-execution"]
for file in $(ls)
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
> do
> echo $file
> done
README.md
```
+++{"lesson_part": "main"}

the `$()` tells bash to run that command first and then hold its output as a variable for use elsewhere



+++{"lesson_part": "main"}

We can modify what is in the `$()`: 
```{code-cell} bash
:tags: ["skip-execution"]
for file in $(ls -a); do echo $file; done
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
.
..
.git
.github
.secret
README.md
```



+++{"lesson_part": "main","type":"heading"}


## Conditionals in bash






+++{"lesson_part": "main"}

We can also do conditional statements

```{code-cell} bash
:tags: ["skip-execution"]
if test -f docs\
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
> then
> echo "file"
> fi
-bash: syntax error near unexpected token `fi'
```

I made a typo, pressing `\` instead of \.  To figure out what happened and understand that error, I used the up arrow key to get back the command: 

```{code-cell} bash
:tags: ["skip-execution"]
if test -f docsthen; echo "file"; fi
```

the `\` is interpetted as nothing so then without the `then` keyword the `fi` is a syntax error

+++{"lesson_part": "main"}
I tried to fix it by adding a `;` after docs
```{code-cell} bash
:tags: ["skip-execution"]
if test -f docs; then; echo "file"; fi
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
-bash: syntax error near unexpected token `;'
```

this was still an error, so I retyped the whole thing: 

+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
if test -f docs
> then
> echo "file"
> fi
```

+++{"lesson_part": "main"}
and used the up arrow here
```{code-cell} bash
:tags: ["skip-execution"]
if test -f docs; then echo "file"; fi
```

I learned that the `then` keyword *can* be on its own line visually, but it is **not** a full line that can be separated with `;`



+++{"lesson_part": "main"}

To recall, the correct `if` is
```{code-cell} bash
:tags: ["skip-execution"]
if test -f docs
> then
> echo "file"
> fi
```
the key parts of this: 
- `test` checks if a file or directory exists
- the `-f` option makes it check if the item is a *file*
- what to do if the condition is met goes after a `then` keyword
- the `fi` (backwards`if`) closes the if statment




This outputs nothing because `docs` doesn't exist, but we can switch branches: 



+++{"lesson_part": "main"}

```{code-cell} bash
:tags: ["skip-execution"]
git checkout organization
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
Previous HEAD position was 99f86bf create a readme closes #1
Switched to branch 'organization'
Your branch is up to date with 'origin/organization'.
```


```{code-cell} bash
:tags: ["skip-execution"]
if test -f docs; then echo "file"; fi
```

Now it outputs nothing because `docs` is a directory not a file. 

+++{"lesson_part": "main"}
If we switch it, we get output: 
```{code-cell} bash
:tags: ["skip-execution"]
if test -f API.md; then echo "file"; fi
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
file
```



+++{"lesson_part": "main","type":"heading"}

## Script files 




+++{"lesson_part": "main"}

We can put bash commands into a file to make them a script

```{code-cell} bash
:tags: ["skip-execution"]
nano filecheck.sh
```


```{code-block} console
:filename: filecheck.sh
echo "hello world"
```

+++{"lesson_part": "main"}
and run it with `bash <filename>`

```{code-cell} bash
:tags: ["skip-execution"]
bash filecheck.sh 
```

+++{"lesson_part": "main","type":"output"}

```{code-block} console
hello world
```


:::::{exercise} 
:label: combinescript

Write a bash script that prints out "file <filename>" for each *file* but not directory in the current working directory

::::::::

:::::{solution} combinescript

```
for file in $(ls)
do 
  if test -f $file
  then
     echo "file" $file
  fi
done
```
::::::::



## Prepare for Next Class 

```{include} ../_prepare/2025-10-21.md
```

## Badges

`````{tab-set}
````{tab-item} Review
```{include} ../_review/2025-10-16.md
```

````

````{tab-item} Practice
```{include} ../_practice/2025-10-16.md
```

````
`````



## Experience Report Evidence

## Questions After Today's Class 